diff -Nur freetype-2.8/builds/freetype.mk freetype-2.8.compiles-with-mactype/builds/freetype.mk
--- freetype-2.8/builds/freetype.mk	2017-03-30 05:20:23.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/builds/freetype.mk	2017-10-09 19:43:58.949285100 -0500
@@ -161,6 +161,7 @@
              $(CFLAGS) \
              $DFT2_BUILD_LIBRARY \
              $DFT_CONFIG_MODULES_H="<ftmodule.h>" \
+			 $D_GNU_SOURCE \
              $(FTOPTION_FLAG)
 
 
Binary files freetype-2.8/builds/windows/vc2010/.vs/freetype/v15/.suo and freetype-2.8.compiles-with-mactype/builds/windows/vc2010/.vs/freetype/v15/.suo differ
Binary files freetype-2.8/builds/windows/vc2010/.vs/freetype/v15/Browse.VC.db and freetype-2.8.compiles-with-mactype/builds/windows/vc2010/.vs/freetype/v15/Browse.VC.db differ
Binary files freetype-2.8/builds/windows/vc2010/.vs/freetype/v15/ipch/AutoPCH/17f904435277b780/FTBASE.ipch and freetype-2.8.compiles-with-mactype/builds/windows/vc2010/.vs/freetype/v15/ipch/AutoPCH/17f904435277b780/FTBASE.ipch differ
Binary files freetype-2.8/builds/windows/vc2010/.vs/freetype/v15/ipch/AutoPCH/6dcbfd66bd127905/FTLCDFIL.ipch and freetype-2.8.compiles-with-mactype/builds/windows/vc2010/.vs/freetype/v15/ipch/AutoPCH/6dcbfd66bd127905/FTLCDFIL.ipch differ
Binary files freetype-2.8/builds/windows/vc2010/.vs/freetype/v15/ipch/AutoPCH/a2846f90f2cb71ea/AUTOFIT.ipch and freetype-2.8.compiles-with-mactype/builds/windows/vc2010/.vs/freetype/v15/ipch/AutoPCH/a2846f90f2cb71ea/AUTOFIT.ipch differ
Binary files freetype-2.8/builds/windows/vc2010/.vs/freetype/v15/ipch/AutoPCH/c00141d79d7e0c1a/SMOOTH.ipch and freetype-2.8.compiles-with-mactype/builds/windows/vc2010/.vs/freetype/v15/ipch/AutoPCH/c00141d79d7e0c1a/SMOOTH.ipch differ
Binary files freetype-2.8/builds/windows/vc2010/.vs/freetype/v15/ipch/AutoPCH/dd77b19db02bc17f/FTINIT.ipch and freetype-2.8.compiles-with-mactype/builds/windows/vc2010/.vs/freetype/v15/ipch/AutoPCH/dd77b19db02bc17f/FTINIT.ipch differ
diff -Nur freetype-2.8/configure freetype-2.8.compiles-with-mactype/configure
--- freetype-2.8/configure	2017-05-03 16:24:38.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/configure	2017-10-09 19:43:58.950285600 -0500
@@ -13,6 +13,8 @@
 # Call the `configure' script located in `builds/unix'.
 #
 
+export LDFLAGS="$LDFLAGS -lm"
+
 rm -f config.mk builds/unix/unix-def.mk builds/unix/unix-cc.mk
 
 # respect GNUMAKE environment variable for backward compatibility
diff -Nur freetype-2.8/devel/ftoption.h freetype-2.8.compiles-with-mactype/devel/ftoption.h
--- freetype-2.8/devel/ftoption.h	2017-03-30 05:20:23.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/devel/ftoption.h	2017-10-09 19:43:58.951786300 -0500
@@ -626,6 +626,16 @@
   /*                                                                       */
 #define TT_CONFIG_OPTION_BYTECODE_INTERPRETER
 
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define FT_CONFIG_OPTION_INFINALITY_PATCHSET if you want to enable     */
+  /* all additional infinality patches, which are configured via env       */
+  /* variables.                                                            */
+  /*                                                                       */
+  /*   This option requires TT_CONFIG_OPTION_SUBPIXEL_HINTING to           */
+  /*   defined.                                                            */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_INFINALITY_PATCHSET
 
   /*************************************************************************/
   /*                                                                       */
diff -Nur freetype-2.8/include/freetype/config/ftoption.h freetype-2.8.compiles-with-mactype/include/freetype/config/ftoption.h
--- freetype-2.8/include/freetype/config/ftoption.h	2017-05-01 02:39:06.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/include/freetype/config/ftoption.h	2017-10-09 19:45:37.062820200 -0500
@@ -122,7 +122,7 @@
   /* This is done to allow FreeType clients to run unmodified, forcing     */
   /* them to display normal gray-level anti-aliased glyphs.                */
   /*                                                                       */
-/* #define FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
+#define FT_CONFIG_OPTION_SUBPIXEL_RENDERING
 
 
   /*************************************************************************/
@@ -626,6 +626,17 @@
   /*                                                                       */
 #define TT_CONFIG_OPTION_BYTECODE_INTERPRETER
 
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define FT_CONFIG_OPTION_INFINALITY_PATCHSET if you want to enable     */
+  /* all additional infinality patches, which are configured via env       */
+  /* variables.                                                            */
+  /*                                                                       */
+  /*   This option requires TT_CONFIG_OPTION_SUBPIXEL_HINTING to           */
+  /*   defined.                                                            */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_INFINALITY_PATCHSET
+
 
   /*************************************************************************/
   /*                                                                       */
@@ -684,8 +695,8 @@
   /* [1] http://www.microsoft.com/typography/cleartype/truetypecleartype.aspx */
   /*                                                                       */
 /* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING  1         */
-#define TT_CONFIG_OPTION_SUBPIXEL_HINTING  2
-/* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING  ( 1 | 2 ) */
+/* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING  1 */
+#define TT_CONFIG_OPTION_SUBPIXEL_HINTING  ( 1 | 2 )
 
 
   /*************************************************************************/
@@ -865,7 +876,7 @@
   /* If this option is activated, it can be controlled with the            */
   /* `no-long-family-names' property of the pcf driver module.             */
   /*                                                                       */
-/* #define PCF_CONFIG_OPTION_LONG_FAMILY_NAMES */
+#define PCF_CONFIG_OPTION_LONG_FAMILY_NAMES
 
 
   /*************************************************************************/
diff -Nur freetype-2.8/include/freetype/config/ftoption.h.orig freetype-2.8.compiles-with-mactype/include/freetype/config/ftoption.h.orig
--- freetype-2.8/include/freetype/config/ftoption.h.orig	1969-12-31 18:00:00.000000000 -0600
+++ freetype-2.8.compiles-with-mactype/include/freetype/config/ftoption.h.orig	2017-10-09 19:43:58.953789100 -0500
@@ -0,0 +1,1004 @@
+/***************************************************************************/
+/*                                                                         */
+/*  ftoption.h                                                             */
+/*                                                                         */
+/*    User-selectable configuration macros (specification only).           */
+/*                                                                         */
+/*  Copyright 1996-2017 by                                                 */
+/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */
+/*                                                                         */
+/*  This file is part of the FreeType project, and may only be used,       */
+/*  modified, and distributed under the terms of the FreeType project      */
+/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */
+/*  this file you indicate that you have read the license and              */
+/*  understand and accept it fully.                                        */
+/*                                                                         */
+/***************************************************************************/
+
+
+#ifndef FTOPTION_H_
+#define FTOPTION_H_
+
+
+#include <ft2build.h>
+
+
+FT_BEGIN_HEADER
+
+  /*************************************************************************/
+  /*                                                                       */
+  /*                 USER-SELECTABLE CONFIGURATION MACROS                  */
+  /*                                                                       */
+  /* This file contains the default configuration macro definitions for    */
+  /* a standard build of the FreeType library.  There are three ways to    */
+  /* use this file to build project-specific versions of the library:      */
+  /*                                                                       */
+  /*  - You can modify this file by hand, but this is not recommended in   */
+  /*    cases where you would like to build several versions of the        */
+  /*    library from a single source directory.                            */
+  /*                                                                       */
+  /*  - You can put a copy of this file in your build directory, more      */
+  /*    precisely in `$BUILD/freetype/config/ftoption.h', where `$BUILD'   */
+  /*    is the name of a directory that is included _before_ the FreeType  */
+  /*    include path during compilation.                                   */
+  /*                                                                       */
+  /*    The default FreeType Makefiles and Jamfiles use the build          */
+  /*    directory `builds/<system>' by default, but you can easily change  */
+  /*    that for your own projects.                                        */
+  /*                                                                       */
+  /*  - Copy the file <ft2build.h> to `$BUILD/ft2build.h' and modify it    */
+  /*    slightly to pre-define the macro FT_CONFIG_OPTIONS_H used to       */
+  /*    locate this file during the build.  For example,                   */
+  /*                                                                       */
+  /*      #define FT_CONFIG_OPTIONS_H  <myftoptions.h>                     */
+  /*      #include <freetype/config/ftheader.h>                            */
+  /*                                                                       */
+  /*    will use `$BUILD/myftoptions.h' instead of this file for macro     */
+  /*    definitions.                                                       */
+  /*                                                                       */
+  /*    Note also that you can similarly pre-define the macro              */
+  /*    FT_CONFIG_MODULES_H used to locate the file listing of the modules */
+  /*    that are statically linked to the library at compile time.  By     */
+  /*    default, this file is <freetype/config/ftmodule.h>.                */
+  /*                                                                       */
+  /* We highly recommend using the third method whenever possible.         */
+  /*                                                                       */
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /**** G E N E R A L   F R E E T Y P E   2   C O N F I G U R A T I O N ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* If you enable this configuration option, FreeType recognizes an       */
+  /* environment variable called `FREETYPE_PROPERTIES', which can be used  */
+  /* to control the various font drivers and modules.  The controllable    */
+  /* properties are listed in the section `Controlling FreeType Modules'   */
+  /* in the reference's table of contents; currently there are properties  */
+  /* for the auto-hinter (file `ftautoh.h'), CFF (file `ftcffdrv.h'),      */
+  /* TrueType (file `ftttdrv.h'), and PCF (file `ftpcfdrv.h').             */
+  /*                                                                       */
+  /* `FREETYPE_PROPERTIES' has the following syntax form (broken here into */
+  /* multiple lines for better readability).                               */
+  /*                                                                       */
+  /*   <optional whitespace>                                               */
+  /*   <module-name1> ':'                                                  */
+  /*   <property-name1> '=' <property-value1>                              */
+  /*   <whitespace>                                                        */
+  /*   <module-name2> ':'                                                  */
+  /*   <property-name2> '=' <property-value2>                              */
+  /*   ...                                                                 */
+  /*                                                                       */
+  /* Example:                                                              */
+  /*                                                                       */
+  /*   FREETYPE_PROPERTIES=truetype:interpreter-version=35 \               */
+  /*                       cff:no-stem-darkening=1 \                       */
+  /*                       autofitter:warping=1                            */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_ENVIRONMENT_PROPERTIES
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Uncomment the line below if you want to activate sub-pixel rendering  */
+  /* (a.k.a. LCD rendering, or ClearType) in this build of the library.    */
+  /*                                                                       */
+  /* Note that this feature is covered by several Microsoft patents        */
+  /* and should not be activated in any default build of the library.      */
+  /*                                                                       */
+  /* This macro has no impact on the FreeType API, only on its             */
+  /* _implementation_.  For example, using FT_RENDER_MODE_LCD when calling */
+  /* FT_Render_Glyph still generates a bitmap that is 3 times wider than   */
+  /* the original size in case this macro isn't defined; however, each     */
+  /* triplet of subpixels has R=G=B.                                       */
+  /*                                                                       */
+  /* This is done to allow FreeType clients to run unmodified, forcing     */
+  /* them to display normal gray-level anti-aliased glyphs.                */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_SUBPIXEL_RENDERING
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Many compilers provide a non-ANSI 64-bit data type that can be used   */
+  /* by FreeType to speed up some computations.  However, this will create */
+  /* some problems when compiling the library in strict ANSI mode.         */
+  /*                                                                       */
+  /* For this reason, the use of 64-bit integers is normally disabled when */
+  /* the __STDC__ macro is defined.  You can however disable this by       */
+  /* defining the macro FT_CONFIG_OPTION_FORCE_INT64 here.                 */
+  /*                                                                       */
+  /* For most compilers, this will only create compilation warnings when   */
+  /* building the library.                                                 */
+  /*                                                                       */
+  /* ObNote: The compiler-specific 64-bit integers are detected in the     */
+  /*         file `ftconfig.h' either statically or through the            */
+  /*         `configure' script on supported platforms.                    */
+  /*                                                                       */
+#undef FT_CONFIG_OPTION_FORCE_INT64
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* If this macro is defined, do not try to use an assembler version of   */
+  /* performance-critical functions (e.g. FT_MulFix).  You should only do  */
+  /* that to verify that the assembler function works properly, or to      */
+  /* execute benchmark tests of the various implementations.               */
+/* #define FT_CONFIG_OPTION_NO_ASSEMBLER */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* If this macro is defined, try to use an inlined assembler version of  */
+  /* the `FT_MulFix' function, which is a `hotspot' when loading and       */
+  /* hinting glyphs, and which should be executed as fast as possible.     */
+  /*                                                                       */
+  /* Note that if your compiler or CPU is not supported, this will default */
+  /* to the standard and portable implementation found in `ftcalc.c'.      */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_INLINE_MULFIX
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* LZW-compressed file support.                                          */
+  /*                                                                       */
+  /*   FreeType now handles font files that have been compressed with the  */
+  /*   `compress' program.  This is mostly used to parse many of the PCF   */
+  /*   files that come with various X11 distributions.  The implementation */
+  /*   uses NetBSD's `zopen' to partially uncompress the file on the fly   */
+  /*   (see src/lzw/ftgzip.c).                                             */
+  /*                                                                       */
+  /*   Define this macro if you want to enable this `feature'.             */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_USE_LZW
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Gzip-compressed file support.                                         */
+  /*                                                                       */
+  /*   FreeType now handles font files that have been compressed with the  */
+  /*   `gzip' program.  This is mostly used to parse many of the PCF files */
+  /*   that come with XFree86.  The implementation uses `zlib' to          */
+  /*   partially uncompress the file on the fly (see src/gzip/ftgzip.c).   */
+  /*                                                                       */
+  /*   Define this macro if you want to enable this `feature'.  See also   */
+  /*   the macro FT_CONFIG_OPTION_SYSTEM_ZLIB below.                       */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_USE_ZLIB
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* ZLib library selection                                                */
+  /*                                                                       */
+  /*   This macro is only used when FT_CONFIG_OPTION_USE_ZLIB is defined.  */
+  /*   It allows FreeType's `ftgzip' component to link to the system's     */
+  /*   installation of the ZLib library.  This is useful on systems like   */
+  /*   Unix or VMS where it generally is already available.                */
+  /*                                                                       */
+  /*   If you let it undefined, the component will use its own copy        */
+  /*   of the zlib sources instead.  These have been modified to be        */
+  /*   included directly within the component and *not* export external    */
+  /*   function names.  This allows you to link any program with FreeType  */
+  /*   _and_ ZLib without linking conflicts.                               */
+  /*                                                                       */
+  /*   Do not #undef this macro here since the build system might define   */
+  /*   it for certain configurations only.                                 */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_SYSTEM_ZLIB */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Bzip2-compressed file support.                                        */
+  /*                                                                       */
+  /*   FreeType now handles font files that have been compressed with the  */
+  /*   `bzip2' program.  This is mostly used to parse many of the PCF      */
+  /*   files that come with XFree86.  The implementation uses `libbz2' to  */
+  /*   partially uncompress the file on the fly (see src/bzip2/ftbzip2.c). */
+  /*   Contrary to gzip, bzip2 currently is not included and need to use   */
+  /*   the system available bzip2 implementation.                          */
+  /*                                                                       */
+  /*   Define this macro if you want to enable this `feature'.             */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_USE_BZIP2 */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define to disable the use of file stream functions and types, FILE,   */
+  /* fopen() etc.  Enables the use of smaller system libraries on embedded */
+  /* systems that have multiple system libraries, some with or without     */
+  /* file stream support, in the cases where file stream support is not    */
+  /* necessary such as memory loading of font files.                       */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_DISABLE_STREAM_SUPPORT */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* PNG bitmap support.                                                   */
+  /*                                                                       */
+  /*   FreeType now handles loading color bitmap glyphs in the PNG format. */
+  /*   This requires help from the external libpng library.  Uncompressed  */
+  /*   color bitmaps do not need any external libraries and will be        */
+  /*   supported regardless of this configuration.                         */
+  /*                                                                       */
+  /*   Define this macro if you want to enable this `feature'.             */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_USE_PNG */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* HarfBuzz support.                                                     */
+  /*                                                                       */
+  /*   FreeType uses the HarfBuzz library to improve auto-hinting of       */
+  /*   OpenType fonts.  If available, many glyphs not directly addressable */
+  /*   by a font's character map will be hinted also.                      */
+  /*                                                                       */
+  /*   Define this macro if you want to enable this `feature'.             */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_USE_HARFBUZZ */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* DLL export compilation                                                */
+  /*                                                                       */
+  /*   When compiling FreeType as a DLL, some systems/compilers need a     */
+  /*   special keyword in front OR after the return type of function       */
+  /*   declarations.                                                       */
+  /*                                                                       */
+  /*   Two macros are used within the FreeType source code to define       */
+  /*   exported library functions: FT_EXPORT and FT_EXPORT_DEF.            */
+  /*                                                                       */
+  /*     FT_EXPORT( return_type )                                          */
+  /*                                                                       */
+  /*       is used in a function declaration, as in                        */
+  /*                                                                       */
+  /*         FT_EXPORT( FT_Error )                                         */
+  /*         FT_Init_FreeType( FT_Library*  alibrary );                    */
+  /*                                                                       */
+  /*                                                                       */
+  /*     FT_EXPORT_DEF( return_type )                                      */
+  /*                                                                       */
+  /*       is used in a function definition, as in                         */
+  /*                                                                       */
+  /*         FT_EXPORT_DEF( FT_Error )                                     */
+  /*         FT_Init_FreeType( FT_Library*  alibrary )                     */
+  /*         {                                                             */
+  /*           ... some code ...                                           */
+  /*           return FT_Err_Ok;                                           */
+  /*         }                                                             */
+  /*                                                                       */
+  /*   You can provide your own implementation of FT_EXPORT and            */
+  /*   FT_EXPORT_DEF here if you want.  If you leave them undefined, they  */
+  /*   will be later automatically defined as `extern return_type' to      */
+  /*   allow normal compilation.                                           */
+  /*                                                                       */
+  /*   Do not #undef these macros here since the build system might define */
+  /*   them for certain configurations only.                               */
+  /*                                                                       */
+/* #define FT_EXPORT(x)      extern x */
+/* #define FT_EXPORT_DEF(x)  x */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Glyph Postscript Names handling                                       */
+  /*                                                                       */
+  /*   By default, FreeType 2 is compiled with the `psnames' module.  This */
+  /*   module is in charge of converting a glyph name string into a        */
+  /*   Unicode value, or return a Macintosh standard glyph name for the    */
+  /*   use with the TrueType `post' table.                                 */
+  /*                                                                       */
+  /*   Undefine this macro if you do not want `psnames' compiled in your   */
+  /*   build of FreeType.  This has the following effects:                 */
+  /*                                                                       */
+  /*   - The TrueType driver will provide its own set of glyph names,      */
+  /*     if you build it to support postscript names in the TrueType       */
+  /*     `post' table.                                                     */
+  /*                                                                       */
+  /*   - The Type 1 driver will not be able to synthesize a Unicode        */
+  /*     charmap out of the glyphs found in the fonts.                     */
+  /*                                                                       */
+  /*   You would normally undefine this configuration macro when building  */
+  /*   a version of FreeType that doesn't contain a Type 1 or CFF driver.  */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_POSTSCRIPT_NAMES
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Postscript Names to Unicode Values support                            */
+  /*                                                                       */
+  /*   By default, FreeType 2 is built with the `PSNames' module compiled  */
+  /*   in.  Among other things, the module is used to convert a glyph name */
+  /*   into a Unicode value.  This is especially useful in order to        */
+  /*   synthesize on the fly a Unicode charmap from the CFF/Type 1 driver  */
+  /*   through a big table named the `Adobe Glyph List' (AGL).             */
+  /*                                                                       */
+  /*   Undefine this macro if you do not want the Adobe Glyph List         */
+  /*   compiled in your `PSNames' module.  The Type 1 driver will not be   */
+  /*   able to synthesize a Unicode charmap out of the glyphs found in the */
+  /*   fonts.                                                              */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_ADOBE_GLYPH_LIST
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Support for Mac fonts                                                 */
+  /*                                                                       */
+  /*   Define this macro if you want support for outline fonts in Mac      */
+  /*   format (mac dfont, mac resource, macbinary containing a mac         */
+  /*   resource) on non-Mac platforms.                                     */
+  /*                                                                       */
+  /*   Note that the `FOND' resource isn't checked.                        */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_MAC_FONTS
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Guessing methods to access embedded resource forks                    */
+  /*                                                                       */
+  /*   Enable extra Mac fonts support on non-Mac platforms (e.g.           */
+  /*   GNU/Linux).                                                         */
+  /*                                                                       */
+  /*   Resource forks which include fonts data are stored sometimes in     */
+  /*   locations which users or developers don't expected.  In some cases, */
+  /*   resource forks start with some offset from the head of a file.  In  */
+  /*   other cases, the actual resource fork is stored in file different   */
+  /*   from what the user specifies.  If this option is activated,         */
+  /*   FreeType tries to guess whether such offsets or different file      */
+  /*   names must be used.                                                 */
+  /*                                                                       */
+  /*   Note that normal, direct access of resource forks is controlled via */
+  /*   the FT_CONFIG_OPTION_MAC_FONTS option.                              */
+  /*                                                                       */
+#ifdef FT_CONFIG_OPTION_MAC_FONTS
+#define FT_CONFIG_OPTION_GUESSING_EMBEDDED_RFORK
+#endif
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Allow the use of FT_Incremental_Interface to load typefaces that      */
+  /* contain no glyph data, but supply it via a callback function.         */
+  /* This is required by clients supporting document formats which         */
+  /* supply font data incrementally as the document is parsed, such        */
+  /* as the Ghostscript interpreter for the PostScript language.           */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_INCREMENTAL
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* The size in bytes of the render pool used by the scan-line converter  */
+  /* to do all of its work.                                                */
+  /*                                                                       */
+#define FT_RENDER_POOL_SIZE  16384L
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* FT_MAX_MODULES                                                        */
+  /*                                                                       */
+  /*   The maximum number of modules that can be registered in a single    */
+  /*   FreeType library object.  32 is the default.                        */
+  /*                                                                       */
+#define FT_MAX_MODULES  32
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Debug level                                                           */
+  /*                                                                       */
+  /*   FreeType can be compiled in debug or trace mode.  In debug mode,    */
+  /*   errors are reported through the `ftdebug' component.  In trace      */
+  /*   mode, additional messages are sent to the standard output during    */
+  /*   execution.                                                          */
+  /*                                                                       */
+  /*   Define FT_DEBUG_LEVEL_ERROR to build the library in debug mode.     */
+  /*   Define FT_DEBUG_LEVEL_TRACE to build it in trace mode.              */
+  /*                                                                       */
+  /*   Don't define any of these macros to compile in `release' mode!      */
+  /*                                                                       */
+  /*   Do not #undef these macros here since the build system might define */
+  /*   them for certain configurations only.                               */
+  /*                                                                       */
+/* #define FT_DEBUG_LEVEL_ERROR */
+/* #define FT_DEBUG_LEVEL_TRACE */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Autofitter debugging                                                  */
+  /*                                                                       */
+  /*   If FT_DEBUG_AUTOFIT is defined, FreeType provides some means to     */
+  /*   control the autofitter behaviour for debugging purposes with global */
+  /*   boolean variables (consequently, you should *never* enable this     */
+  /*   while compiling in `release' mode):                                 */
+  /*                                                                       */
+  /*     _af_debug_disable_horz_hints                                      */
+  /*     _af_debug_disable_vert_hints                                      */
+  /*     _af_debug_disable_blue_hints                                      */
+  /*                                                                       */
+  /*   Additionally, the following functions provide dumps of various      */
+  /*   internal autofit structures to stdout (using `printf'):             */
+  /*                                                                       */
+  /*     af_glyph_hints_dump_points                                        */
+  /*     af_glyph_hints_dump_segments                                      */
+  /*     af_glyph_hints_dump_edges                                         */
+  /*     af_glyph_hints_get_num_segments                                   */
+  /*     af_glyph_hints_get_segment_offset                                 */
+  /*                                                                       */
+  /*   As an argument, they use another global variable:                   */
+  /*                                                                       */
+  /*     _af_debug_hints                                                   */
+  /*                                                                       */
+  /*   Please have a look at the `ftgrid' demo program to see how those    */
+  /*   variables and macros should be used.                                */
+  /*                                                                       */
+  /*   Do not #undef these macros here since the build system might define */
+  /*   them for certain configurations only.                               */
+  /*                                                                       */
+/* #define FT_DEBUG_AUTOFIT */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Memory Debugging                                                      */
+  /*                                                                       */
+  /*   FreeType now comes with an integrated memory debugger that is       */
+  /*   capable of detecting simple errors like memory leaks or double      */
+  /*   deletes.  To compile it within your build of the library, you       */
+  /*   should define FT_DEBUG_MEMORY here.                                 */
+  /*                                                                       */
+  /*   Note that the memory debugger is only activated at runtime when     */
+  /*   when the _environment_ variable `FT2_DEBUG_MEMORY' is defined also! */
+  /*                                                                       */
+  /*   Do not #undef this macro here since the build system might define   */
+  /*   it for certain configurations only.                                 */
+  /*                                                                       */
+/* #define FT_DEBUG_MEMORY */
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Module errors                                                         */
+  /*                                                                       */
+  /*   If this macro is set (which is _not_ the default), the higher byte  */
+  /*   of an error code gives the module in which the error has occurred,  */
+  /*   while the lower byte is the real error code.                        */
+  /*                                                                       */
+  /*   Setting this macro makes sense for debugging purposes only, since   */
+  /*   it would break source compatibility of certain programs that use    */
+  /*   FreeType 2.                                                         */
+  /*                                                                       */
+  /*   More details can be found in the files ftmoderr.h and fterrors.h.   */
+  /*                                                                       */
+#undef FT_CONFIG_OPTION_USE_MODULE_ERRORS
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Position Independent Code                                             */
+  /*                                                                       */
+  /*   If this macro is set (which is _not_ the default), FreeType2 will   */
+  /*   avoid creating constants that require address fixups.  Instead the  */
+  /*   constants will be moved into a struct and additional intialization  */
+  /*   code will be used.                                                  */
+  /*                                                                       */
+  /*   Setting this macro is needed for systems that prohibit address      */
+  /*   fixups, such as BREW.  [Note that standard compilers like gcc or    */
+  /*   clang handle PIC generation automatically; you don't have to set    */
+  /*   FT_CONFIG_OPTION_PIC, which is only necessary for very special      */
+  /*   compilers.]                                                         */
+  /*                                                                       */
+  /*   Note that FT_CONFIG_OPTION_PIC support is not available for all     */
+  /*   modules (see `modules.cfg' for a complete list).  For building with */
+  /*   FT_CONFIG_OPTION_PIC support, do the following.                     */
+  /*                                                                       */
+  /*     0. Clone the repository.                                          */
+  /*     1. Define FT_CONFIG_OPTION_PIC.                                   */
+  /*     2. Remove all subdirectories in `src' that don't have             */
+  /*        FT_CONFIG_OPTION_PIC support.                                  */
+  /*     3. Comment out the corresponding modules in `modules.cfg'.        */
+  /*     4. Compile.                                                       */
+  /*                                                                       */
+/* #define FT_CONFIG_OPTION_PIC */
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****        S F N T   D R I V E R    C O N F I G U R A T I O N       ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_EMBEDDED_BITMAPS if you want to support       */
+  /* embedded bitmaps in all formats using the SFNT module (namely         */
+  /* TrueType & OpenType).                                                 */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_EMBEDDED_BITMAPS
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_POSTSCRIPT_NAMES if you want to be able to    */
+  /* load and enumerate the glyph Postscript names in a TrueType or        */
+  /* OpenType file.                                                        */
+  /*                                                                       */
+  /* Note that when you do not compile the `PSNames' module by undefining  */
+  /* the above FT_CONFIG_OPTION_POSTSCRIPT_NAMES, the `sfnt' module will   */
+  /* contain additional code used to read the PS Names table from a font.  */
+  /*                                                                       */
+  /* (By default, the module uses `PSNames' to extract glyph names.)       */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_POSTSCRIPT_NAMES
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_SFNT_NAMES if your applications need to       */
+  /* access the internal name table in a SFNT-based format like TrueType   */
+  /* or OpenType.  The name table contains various strings used to         */
+  /* describe the font, like family name, copyright, version, etc.  It     */
+  /* does not contain any glyph name though.                               */
+  /*                                                                       */
+  /* Accessing SFNT names is done through the functions declared in        */
+  /* `ftsnames.h'.                                                         */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_SFNT_NAMES
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* TrueType CMap support                                                 */
+  /*                                                                       */
+  /*   Here you can fine-tune which TrueType CMap table format shall be    */
+  /*   supported.                                                          */
+#define TT_CONFIG_CMAP_FORMAT_0
+#define TT_CONFIG_CMAP_FORMAT_2
+#define TT_CONFIG_CMAP_FORMAT_4
+#define TT_CONFIG_CMAP_FORMAT_6
+#define TT_CONFIG_CMAP_FORMAT_8
+#define TT_CONFIG_CMAP_FORMAT_10
+#define TT_CONFIG_CMAP_FORMAT_12
+#define TT_CONFIG_CMAP_FORMAT_13
+#define TT_CONFIG_CMAP_FORMAT_14
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****    T R U E T Y P E   D R I V E R    C O N F I G U R A T I O N   ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_BYTECODE_INTERPRETER if you want to compile   */
+  /* a bytecode interpreter in the TrueType driver.                        */
+  /*                                                                       */
+  /* By undefining this, you will only compile the code necessary to load  */
+  /* TrueType glyphs without hinting.                                      */
+  /*                                                                       */
+  /*   Do not #undef this macro here, since the build system might         */
+  /*   define it for certain configurations only.                          */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_BYTECODE_INTERPRETER
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define FT_CONFIG_OPTION_INFINALITY_PATCHSET if you want to enable     */
+  /* all additional infinality patches, which are configured via env       */
+  /* variables.                                                            */
+  /*                                                                       */
+  /*   This option requires TT_CONFIG_OPTION_SUBPIXEL_HINTING to           */
+  /*   defined.                                                            */
+  /*                                                                       */
+#define FT_CONFIG_OPTION_INFINALITY_PATCHSET
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_SUBPIXEL_HINTING if you want to compile       */
+  /* subpixel hinting support into the TrueType driver.  This modifies the */
+  /* TrueType hinting mechanism when anything but FT_RENDER_MODE_MONO is   */
+  /* requested.                                                            */
+  /*                                                                       */
+  /* In particular, it modifies the bytecode interpreter to interpret (or  */
+  /* not) instructions in a certain way so that all TrueType fonts look    */
+  /* like they do in a Windows ClearType (DirectWrite) environment.  See   */
+  /* [1] for a technical overview on what this means.  See `ttinterp.h'    */
+  /* for more details on the LEAN option.                                  */
+  /*                                                                       */
+  /* There are three possible values.                                      */
+  /*                                                                       */
+  /* Value 1:                                                              */
+  /*    This value is associated with the `Infinality' moniker,            */
+  /*    contributed by an individual nicknamed Infinality with the goal of */
+  /*    making TrueType fonts render better than on Windows.  A high       */
+  /*    amount of configurability and flexibility, down to rules for       */
+  /*    single glyphs in fonts, but also very slow.  Its experimental and  */
+  /*    slow nature and the original developer losing interest meant that  */
+  /*    this option was never enabled in default builds.                   */
+  /*                                                                       */
+  /*    The corresponding interpreter version is v38.                      */
+  /*                                                                       */
+  /* Value 2:                                                              */
+  /*    The new default mode for the TrueType driver.  The Infinality code */
+  /*    base was stripped to the bare minimum and all configurability      */
+  /*    removed in the name of speed and simplicity.  The configurability  */
+  /*    was mainly aimed at legacy fonts like Arial, Times New Roman, or   */
+  /*    Courier.  Legacy fonts are fonts that modify vertical stems to     */
+  /*    achieve clean black-and-white bitmaps.  The new mode focuses on    */
+  /*    applying a minimal set of rules to all fonts indiscriminately so   */
+  /*    that modern and web fonts render well while legacy fonts render    */
+  /*    okay.                                                              */
+  /*                                                                       */
+  /*    The corresponding interpreter version is v40.                      */
+  /*                                                                       */
+  /* Value 3:                                                              */
+  /*    Compile both, making both v38 and v40 available (the latter is the */
+  /*    default).                                                          */
+  /*                                                                       */
+  /* By undefining these, you get rendering behavior like on Windows       */
+  /* without ClearType, i.e., Windows XP without ClearType enabled and     */
+  /* Win9x (interpreter version v35).  Or not, depending on how much       */
+  /* hinting blood and testing tears the font designer put into a given    */
+  /* font.  If you define one or both subpixel hinting options, you can    */
+  /* switch between between v35 and the ones you define (using             */
+  /* `FT_Property_Set').                                                   */
+  /*                                                                       */
+  /* This option requires TT_CONFIG_OPTION_BYTECODE_INTERPRETER to be      */
+  /* defined.                                                              */
+  /*                                                                       */
+  /* [1] http://www.microsoft.com/typography/cleartype/truetypecleartype.aspx */
+  /*                                                                       */
+/* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING  1         */
+/* #define TT_CONFIG_OPTION_SUBPIXEL_HINTING  1 */
+#define TT_CONFIG_OPTION_SUBPIXEL_HINTING  ( 1 | 2 )
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED to compile the        */
+  /* TrueType glyph loader to use Apple's definition of how to handle      */
+  /* component offsets in composite glyphs.                                */
+  /*                                                                       */
+  /* Apple and MS disagree on the default behavior of component offsets    */
+  /* in composites.  Apple says that they should be scaled by the scaling  */
+  /* factors in the transformation matrix (roughly, it's more complex)     */
+  /* while MS says they should not.  OpenType defines two bits in the      */
+  /* composite flags array which can be used to disambiguate, but old      */
+  /* fonts will not have them.                                             */
+  /*                                                                       */
+  /*   http://www.microsoft.com/typography/otspec/glyf.htm                 */
+  /*   https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6glyf.html */
+  /*                                                                       */
+#undef TT_CONFIG_OPTION_COMPONENT_OFFSET_SCALED
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_GX_VAR_SUPPORT if you want to include         */
+  /* support for Apple's distortable font technology (fvar, gvar, cvar,    */
+  /* and avar tables).  This has many similarities to Type 1 Multiple      */
+  /* Masters support.                                                      */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_GX_VAR_SUPPORT
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define TT_CONFIG_OPTION_BDF if you want to include support for        */
+  /* an embedded `BDF ' table within SFNT-based bitmap formats.            */
+  /*                                                                       */
+#define TT_CONFIG_OPTION_BDF
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Option TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES controls the maximum     */
+  /* number of bytecode instructions executed for a single run of the      */
+  /* bytecode interpreter, needed to prevent infinite loops.  You don't    */
+  /* want to change this except for very special situations (e.g., making  */
+  /* a library fuzzer spend less time to handle broken fonts).             */
+  /*                                                                       */
+  /* It is not expected that this value is ever modified by a configuring  */
+  /* script; instead, it gets surrounded with #ifndef ... #endif so that   */
+  /* the value can be set as a preprocessor option on the compiler's       */
+  /* command line.                                                         */
+  /*                                                                       */
+#ifndef TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES
+#define TT_CONFIG_OPTION_MAX_RUNNABLE_OPCODES  1000000L
+#endif
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****      T Y P E 1   D R I V E R    C O N F I G U R A T I O N       ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* T1_MAX_DICT_DEPTH is the maximum depth of nest dictionaries and       */
+  /* arrays in the Type 1 stream (see t1load.c).  A minimum of 4 is        */
+  /* required.                                                             */
+  /*                                                                       */
+#define T1_MAX_DICT_DEPTH  5
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* T1_MAX_SUBRS_CALLS details the maximum number of nested sub-routine   */
+  /* calls during glyph loading.                                           */
+  /*                                                                       */
+#define T1_MAX_SUBRS_CALLS  16
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* T1_MAX_CHARSTRING_OPERANDS is the charstring stack's capacity.  A     */
+  /* minimum of 16 is required.                                            */
+  /*                                                                       */
+  /* The Chinese font MingTiEG-Medium (CNS 11643 character set) needs 256. */
+  /*                                                                       */
+#define T1_MAX_CHARSTRINGS_OPERANDS  256
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define this configuration macro if you want to prevent the            */
+  /* compilation of `t1afm', which is in charge of reading Type 1 AFM      */
+  /* files into an existing face.  Note that if set, the T1 driver will be */
+  /* unable to produce kerning distances.                                  */
+  /*                                                                       */
+#undef T1_CONFIG_OPTION_NO_AFM
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Define this configuration macro if you want to prevent the            */
+  /* compilation of the Multiple Masters font support in the Type 1        */
+  /* driver.                                                               */
+  /*                                                                       */
+#undef T1_CONFIG_OPTION_NO_MM_SUPPORT
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****         C F F   D R I V E R    C O N F I G U R A T I O N        ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Using CFF_CONFIG_OPTION_DARKENING_PARAMETER_{X,Y}{1,2,3,4} it is      */
+  /* possible to set up the default values of the four control points that */
+  /* define the stem darkening behaviour of the (new) CFF engine.  For     */
+  /* more details please read the documentation of the                     */
+  /* `darkening-parameters' property of the cff driver module (file        */
+  /* `ftcffdrv.h'), which allows the control at run-time.                  */
+  /*                                                                       */
+  /* Do *not* undefine these macros!                                       */
+  /*                                                                       */
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1   500
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1   400
+
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2  1000
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2   275
+
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3  1667
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3   275
+
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4  2333
+#define CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4     0
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* CFF_CONFIG_OPTION_OLD_ENGINE controls whether the pre-Adobe CFF       */
+  /* engine gets compiled into FreeType.  If defined, it is possible to    */
+  /* switch between the two engines using the `hinting-engine' property of */
+  /* the cff driver module.                                                */
+  /*                                                                       */
+/* #define CFF_CONFIG_OPTION_OLD_ENGINE */
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****         P C F   D R I V E R    C O N F I G U R A T I O N        ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* There are many PCF fonts just called `Fixed' which look completely    */
+  /* different, and which have nothing to do with each other.  When        */
+  /* selecting `Fixed' in KDE or Gnome one gets results that appear rather */
+  /* random, the style changes often if one changes the size and one       */
+  /* cannot select some fonts at all.  This option makes the PCF module    */
+  /* prepend the foundry name (plus a space) to the family name.           */
+  /*                                                                       */
+  /* We also check whether we have `wide' characters; all put together, we */
+  /* get family names like `Sony Fixed' or `Misc Fixed Wide'.              */
+  /*                                                                       */
+  /* If this option is activated, it can be controlled with the            */
+  /* `no-long-family-names' property of the pcf driver module.             */
+  /*                                                                       */
+/* #define PCF_CONFIG_OPTION_LONG_FAMILY_NAMES */
+
+
+  /*************************************************************************/
+  /*************************************************************************/
+  /****                                                                 ****/
+  /****    A U T O F I T   M O D U L E    C O N F I G U R A T I O N     ****/
+  /****                                                                 ****/
+  /*************************************************************************/
+  /*************************************************************************/
+
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Compile autofit module with CJK (Chinese, Japanese, Korean) script    */
+  /* support.                                                              */
+  /*                                                                       */
+#define AF_CONFIG_OPTION_CJK
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Compile autofit module with fallback Indic script support, covering   */
+  /* some scripts that the `latin' submodule of the autofit module doesn't */
+  /* (yet) handle.                                                         */
+  /*                                                                       */
+#define AF_CONFIG_OPTION_INDIC
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Compile autofit module with warp hinting.  The idea of the warping    */
+  /* code is to slightly scale and shift a glyph within a single dimension */
+  /* so that as much of its segments are aligned (more or less) on the     */
+  /* grid.  To find out the optimal scaling and shifting value, various    */
+  /* parameter combinations are tried and scored.                          */
+  /*                                                                       */
+  /* This experimental option is active only if the rendering mode is      */
+  /* FT_RENDER_MODE_LIGHT; you can switch warping on and off with the      */
+  /* `warping' property of the auto-hinter (see file `ftautoh.h' for more  */
+  /* information; by default it is switched off).                          */
+  /*                                                                       */
+#define AF_CONFIG_OPTION_USE_WARPER
+
+  /*************************************************************************/
+  /*                                                                       */
+  /* Use TrueType-like size metrics for `light' auto-hinting.              */
+  /*                                                                       */
+  /* It is strongly recommended to avoid this option, which exists only to */
+  /* help some legacy applications retain its appearance and behaviour     */
+  /* with respect to auto-hinted TrueType fonts.                           */
+  /*                                                                       */
+  /* The very reason this option exists at all are GNU/Linux distributions */
+  /* like Fedora that did not un-patch the following change (which was     */
+  /* present in FreeType between versions 2.4.6 and 2.7.1, inclusive).     */
+  /*                                                                       */
+  /*   2011-07-16  Steven Chu  <steven.f.chu@gmail.com>                    */
+  /*                                                                       */
+  /*     [truetype] Fix metrics on size request for scalable fonts.        */
+  /*                                                                       */
+  /* This problematic commit is now reverted (more or less).               */
+  /*                                                                       */
+/* #define AF_CONFIG_OPTION_TT_SIZE_METRICS */
+
+  /* */
+
+
+  /*
+   * This macro is obsolete.  Support has been removed in FreeType
+   * version 2.5.
+   */
+/* #define FT_CONFIG_OPTION_OLD_INTERNALS */
+
+
+  /*
+   * This macro is defined if native TrueType hinting is requested by the
+   * definitions above.
+   */
+#ifdef TT_CONFIG_OPTION_BYTECODE_INTERPRETER
+#define  TT_USE_BYTECODE_INTERPRETER
+
+#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING
+#if TT_CONFIG_OPTION_SUBPIXEL_HINTING & 1
+#define  TT_SUPPORT_SUBPIXEL_HINTING_INFINALITY
+#endif
+
+#if TT_CONFIG_OPTION_SUBPIXEL_HINTING & 2
+#define  TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL
+#endif
+#endif
+#endif
+
+
+  /*
+   * Check CFF darkening parameters.  The checks are the same as in function
+   * `cff_property_set' in file `cffdrivr.c'.
+   */
+#if CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1 < 0   || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2 < 0   || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3 < 0   || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4 < 0   || \
+                                                      \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1 < 0   || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2 < 0   || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3 < 0   || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4 < 0   || \
+                                                      \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1 >        \
+      CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2     || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X2 >        \
+      CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3     || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_X3 >        \
+      CFF_CONFIG_OPTION_DARKENING_PARAMETER_X4     || \
+                                                      \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1 > 500 || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y2 > 500 || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y3 > 500 || \
+    CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y4 > 500
+#error "Invalid CFF darkening parameters!"
+#endif
+
+FT_END_HEADER
+
+
+#endif /* FTOPTION_H_ */
+
+
+/* END */
diff -Nur freetype-2.8/Makefile.orig freetype-2.8.compiles-with-mactype/Makefile.orig
--- freetype-2.8/Makefile.orig	1969-12-31 18:00:00.000000000 -0600
+++ freetype-2.8.compiles-with-mactype/Makefile.orig	2017-10-09 19:45:40.936359400 -0500
@@ -0,0 +1,34 @@
+#
+# FreeType 2 build system -- top-level Makefile
+#
+
+
+# Copyright 1996-2017 by
+# David Turner, Robert Wilhelm, and Werner Lemberg.
+#
+# This file is part of the FreeType project, and may only be used, modified,
+# and distributed under the terms of the FreeType project license,
+# LICENSE.TXT.  By continuing to use, modify, or distribute this file you
+# indicate that you have read the license and understand and accept it
+# fully.
+
+
+# Project names
+#
+PROJECT       := freetype
+PROJECT_TITLE := FreeType
+
+# The variable TOP_DIR holds the path to the topmost directory in the project
+# engine source hierarchy.  If it is not defined, default it to `.'.
+#
+TOP_DIR ?= .
+
+# The variable OBJ_DIR gives the location where object files and the
+# FreeType library are built.
+#
+OBJ_DIR ?= $(TOP_DIR)/objs
+
+
+include $(TOP_DIR)/builds/toplevel.mk
+
+# EOF
diff -Nur freetype-2.8/Makefile.rej freetype-2.8.compiles-with-mactype/Makefile.rej
--- freetype-2.8/Makefile.rej	1969-12-31 18:00:00.000000000 -0600
+++ freetype-2.8.compiles-with-mactype/Makefile.rej	2017-10-09 19:45:40.938861500 -0500
@@ -0,0 +1,17 @@
+--- Makefile
++++ Makefile
+@@ -296,10 +296,10 @@ else
+   # The following programs are not compiled automatically; either comment
+   # out the affected line or use the program name as a Makefile target.
+   #
+-  # EXES += ftchkwd
+-  # EXES += ftmemchk
+-  # EXES += ftpatchk
+-  # EXES += fttimer
++  EXES += ftchkwd
++  EXES += ftmemchk
++  EXES += ftpatchk
++  EXES += fttimer
+   # EXES += testname
+ 
+   exes: $(EXES:%=$(BIN_DIR_2)/%$E)
diff -Nur freetype-2.8/modules.cfg freetype-2.8.compiles-with-mactype/modules.cfg
--- freetype-2.8/modules.cfg	2017-03-30 05:20:23.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/modules.cfg	2017-10-09 19:43:42.903330400 -0500
@@ -120,7 +120,7 @@
 # TrueType GX/AAT table validation.  Needs ftgxval.c below.
 #
 # No FT_CONFIG_OPTION_PIC support.
-# AUX_MODULES += gxvalid
+AUX_MODULES += gxvalid
 
 # Support for streams compressed with gzip (files with suffix .gz).
 #
@@ -143,7 +143,7 @@
 # OpenType table validation.  Needs ftotval.c below.
 #
 # No FT_CONFIG_OPTION_PIC support.
-# AUX_MODULES += otvalid
+AUX_MODULES += otvalid
 
 # Auxiliary PostScript driver component to share common code.
 #
Binary files freetype-2.8/objs/vc2010/Win32/Debug/autofit.obj and freetype-2.8.compiles-with-mactype/objs/vc2010/Win32/Debug/autofit.obj differ
Binary files freetype-2.8/objs/vc2010/Win32/Debug/bdf.obj and freetype-2.8.compiles-with-mactype/objs/vc2010/Win32/Debug/bdf.obj differ
Binary files freetype-2.8/objs/vc2010/Win32/Debug/cff.obj and freetype-2.8.compiles-with-mactype/objs/vc2010/Win32/Debug/cff.obj differ
diff -Nur freetype-2.8/src/autofit/aflatin.c freetype-2.8.compiles-with-mactype/src/autofit/aflatin.c
--- freetype-2.8/src/autofit/aflatin.c	2017-05-01 02:19:42.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/src/autofit/aflatin.c	2017-10-09 19:48:50.953992100 -0500
@@ -24,7 +24,10 @@
 #include "afpic.h"
 #include "aflatin.h"
 #include "aferrors.h"
-
+#include "string.h"
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include "../base/ftinf.h"
+#endif
 
 #ifdef AF_CONFIG_OPTION_USE_WARPER
 #include "afwarp.h"
@@ -40,6 +43,10 @@
 #undef  FT_COMPONENT
 #define FT_COMPONENT  trace_aflatin
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+FT_Pos infinality_cur_width = 0;
+#endif
+
 
   /* needed for computation of round vs. flat segments */
 #define FLAT_THRESHOLD( x )  ( x / 14 )
@@ -1121,7 +1128,10 @@
     FT_Pos        delta;
     AF_LatinAxis  axis;
     FT_UInt       nn;
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    FT_Bool adjust_heights         = FALSE;
+    if(ftinf) adjust_heights=ftinf->autohint_increase_glyph_heights;
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
 
     if ( dim == AF_DIMENSION_HORZ )
     {
@@ -1149,7 +1159,7 @@
     {
       AF_LatinAxis  Axis = &metrics->axis[AF_DIMENSION_VERT];
       AF_LatinBlue  blue = NULL;
-
+      int threshold = 40;
 
       for ( nn = 0; nn < Axis->blue_count; nn++ )
       {
@@ -1159,7 +1169,12 @@
           break;
         }
       }
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+      if ( adjust_heights                                       &&
+           metrics->root.scaler.face->size->metrics.x_ppem < 15 &&
+           metrics->root.scaler.face->size->metrics.x_ppem > 5  )
+        threshold = 52;
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
       if ( blue )
       {
         FT_Pos   scaled;
@@ -1315,7 +1330,13 @@
 
         /* a blue zone is only active if it is less than 3/4 pixels tall */
         dist = FT_MulFix( blue->ref.org - blue->shoot.org, scale );
+
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+        /* Do at low ppems ( ~< 200 ), in order to prevent fringes */
+        if ( dist <= 256 && dist >= -256 )
+#else
         if ( dist <= 48 && dist >= -48 )
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
         {
 #if 0
           FT_Pos  delta1;
@@ -1366,7 +1387,12 @@
             delta2 = -delta2;
 
           blue->ref.fit   = FT_PIX_ROUND( blue->ref.cur );
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+          /* Round to prevent fringes */
+          blue->shoot.fit = FT_PIX_ROUND( blue->ref.fit - delta2 );
+#else
           blue->shoot.fit = blue->ref.fit - delta2;
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
 
 #endif
 
@@ -2504,7 +2530,10 @@
               dist = edge->fpos - blue->shoot.org;
               if ( dist < 0 )
                 dist = -dist;
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+              /* round down to pixels */
+              dist = FT_MulFix( dist, scale ) & ~63;
+#endif
               dist = FT_MulFix( dist, scale );
               if ( dist < best_dist )
               {
@@ -2680,8 +2709,17 @@
     FT_Pos           dist     = width;
     FT_Int           sign     = 0;
     FT_Int           vertical = ( dim == AF_DIMENSION_VERT );
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    FT_Int           infinality_dist = 0;
+    FT_UInt          autohint_snap_stem_height = 0;
+    if( ftinf ) autohint_snap_stem_height=ftinf->autohint_snap_stem_height;
+    if ( autohint_snap_stem_height > 100 )
+        autohint_snap_stem_height = 100;
+    else if ( autohint_snap_stem_height < 0 )
+        autohint_snap_stem_height = 0;
 
-
+    if ( autohint_snap_stem_height == 0 )
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
     if ( !AF_LATIN_HINTS_DO_STEM_ADJUST( hints ) ||
          axis->extra_light                       )
       return width;
@@ -2691,9 +2729,76 @@
       dist = -width;
       sign = 1;
     }
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    /* Calculate snap value differently than standard freetype */
+    if ( autohint_snap_stem_height > 0                              &&
+         ( ( vertical && !AF_LATIN_HINTS_DO_VERT_SNAP( hints ) )  ||
+           ( !vertical && !AF_LATIN_HINTS_DO_HORZ_SNAP( hints ) ) ) )
+    {
+      infinality_dist = af_latin_snap_width( axis->widths,
+                                             axis->width_count, dist );
+
+      if ( metrics->root.scaler.face->size->metrics.x_ppem > 9 &&
+           axis->width_count > 0                               &&
+           abs( axis->widths[0].cur - infinality_dist ) < 32   &&
+           axis->widths[0].cur > 52                            )
+      {
+          const char *style_name=metrics->root.scaler.face->style_name;
+          if ( style_name!=NULL &&
+               ( strstr( style_name, "Regular" )      ||
+                 strstr( style_name, "Book" )         ||
+                 strstr( style_name, "Medium" )       ||
+                 strcmp( style_name, "Italic" ) == 0  ||
+                 strcmp( style_name, "Oblique" ) == 0 )
+              )
+         {
+          /* regular weight */
+          if ( axis->widths[0].cur < 64 )
+            infinality_dist = 64;
+          else if ( axis->widths[0].cur  < 88 )
+            infinality_dist = 64;
+          else if ( axis->widths[0].cur  < 160 )
+            infinality_dist = 128;
+          else if ( axis->widths[0].cur  < 240 )
+            infinality_dist = 190;
+          else infinality_dist = ( infinality_dist ) & ~63;
+        }
+        else
+        {
+          /* bold gets a different threshold */
+          if ( axis->widths[0].cur < 64 )
+            infinality_dist = 64 ;
+          else if ( axis->widths[0].cur  < 108 )
+            infinality_dist = 64;
+          else if ( axis->widths[0].cur  < 160 )
+            infinality_dist = 128;
+          else if ( axis->widths[0].cur  < 222 )
+            infinality_dist = 190;
+          else if ( axis->widths[0].cur  < 288 )
+            infinality_dist = 254;
+          else infinality_dist = ( infinality_dist + 16 ) & ~63;
+        }
 
-    if ( (  vertical && !AF_LATIN_HINTS_DO_VERT_SNAP( hints ) ) ||
+      }
+      if ( infinality_dist < 52 )
+      {
+        if ( metrics->root.scaler.face->size->metrics.x_ppem < 9 )
+        {
+          if ( infinality_dist < 32 )
+            infinality_dist = 32;
+        }
+        else
+          infinality_dist = 64;
+      }
+    }
+    else if ( autohint_snap_stem_height < 100                            &&
+              ( ( vertical && !AF_LATIN_HINTS_DO_VERT_SNAP( hints ) )  ||
+                ( !vertical && !AF_LATIN_HINTS_DO_HORZ_SNAP( hints ) ) ) )
+#else
+
+    if ( ( vertical && !AF_LATIN_HINTS_DO_VERT_SNAP( hints ) ) ||
          ( !vertical && !AF_LATIN_HINTS_DO_HORZ_SNAP( hints ) ) )
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
     {
       /* smooth hinting process: very lightly quantize the stem width */
 
@@ -2785,6 +2890,9 @@
       }
     }
     else
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+      if ( autohint_snap_stem_height < 100 )
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
     {
       /* strong hinting process: snap the stem width to integer pixels */
 
@@ -2792,7 +2900,10 @@
 
 
       dist = af_latin_snap_width( axis->widths, axis->width_count, dist );
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+      if ( autohint_snap_stem_height > 0 )
+        goto Done_Width;
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
       if ( vertical )
       {
         /* in the case of vertical hinting, always round */
@@ -2855,6 +2966,32 @@
     }
 
   Done_Width:
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    if ( axis->widths[0].cur > 42 )
+      /* weighted average */
+      dist = (dist * ( 100 - autohint_snap_stem_height )
+                + infinality_dist * autohint_snap_stem_height ) / 100;
+
+      {
+        int factor = 100;
+        if ( axis->standard_width < 100 )
+          factor = axis->standard_width;
+
+        if ( metrics->root.scaler.face->size->metrics.x_ppem >= 9  && dist < 52 )
+          dist += ( (52 - dist) * factor ) / 100;
+        if ( metrics->root.scaler.face->size->metrics.x_ppem < 9  && dist < 32 )
+          dist += ( (32 - dist) * factor ) / 100;
+
+        if ( axis->standard_width > 100                             &&
+             metrics->root.scaler.face->size->metrics.x_ppem >= 11  &&
+             dist < 64                                              )
+          dist = 64;
+        if ( axis->standard_width > 100                           &&
+             metrics->root.scaler.face->size->metrics.x_ppem >= 9 &&
+             dist < 52                                            )
+          dist = 52;
+      }
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
     if ( sign )
       dist = -dist;
 
@@ -2873,6 +3010,8 @@
     FT_Pos  dist, base_delta;
     FT_Pos  fitted_width;
 
+/* if fitted_width causes stem_edge->pos to land basically on top of an existing
+ * stem_edge->pos, then add or remove 64.  Need to figure out a way to do this */
 
     dist       = stem_edge->opos - base_edge->opos;
     base_delta = base_edge->pos - base_edge->opos;
@@ -3485,8 +3624,11 @@
     int       dim;
 
     AF_LatinAxis  axis;
-
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    FT_Int    emboldening_strength = 0;
+    FT_Bool   use_various_tweaks = FALSE;
+    if( ftinf ) use_various_tweaks=ftinf->use_various_tweaks;
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
     error = af_glyph_hints_reload( hints, outline );
     if ( error )
       goto Exit;
@@ -3556,7 +3698,11 @@
     }
 
     af_glyph_hints_save( hints, outline );
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    {
+      infinality_cur_width = metrics->axis->widths[0].cur;
+    }
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
   Exit:
     return error;
   }
diff -Nur freetype-2.8/src/autofit/aflatin.h freetype-2.8.compiles-with-mactype/src/autofit/aflatin.h
--- freetype-2.8/src/autofit/aflatin.h	2017-03-30 05:20:23.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/src/autofit/aflatin.h	2017-10-09 19:43:58.957791700 -0500
@@ -64,6 +64,9 @@
 
 #define AF_LATIN_MAX_WIDTHS  16
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    extern FT_Pos infinality_cur_width;
+#endif
 
 #define AF_LATIN_BLUE_ACTIVE      ( 1U << 0 ) /* zone height is <= 3/4px   */
 #define AF_LATIN_BLUE_TOP         ( 1U << 1 ) /* we have a top blue zone   */
diff -Nur freetype-2.8/src/autofit/afmodule.c freetype-2.8.compiles-with-mactype/src/autofit/afmodule.c
--- freetype-2.8/src/autofit/afmodule.c	2017-04-14 22:48:22.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/src/autofit/afmodule.c	2017-10-09 19:43:58.959294000 -0500
@@ -22,6 +22,10 @@
 #include "aferrors.h"
 #include "afpic.h"
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include "../base/ftinf.h"
+#endif
+
 #ifdef FT_DEBUG_AUTOFIT
 
 #ifndef FT_MAKE_OPTION_SINGLE_OBJECT
@@ -477,6 +481,9 @@
     module->warping           = 0;
 #endif
     module->no_stem_darkening = TRUE;
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    if(ftinf) module->no_stem_darkening = !ftinf->stem_darkening_autofit;
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
 
     module->darken_params[0]  = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1;
     module->darken_params[1]  = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1;
diff -Nur freetype-2.8/src/base/ftbase.c freetype-2.8.compiles-with-mactype/src/base/ftbase.c
--- freetype-2.8/src/base/ftbase.c	2017-03-30 05:20:23.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/src/base/ftbase.c	2017-10-09 19:43:58.961795500 -0500
@@ -34,6 +34,9 @@
 #include "ftstream.c"
 #include "fttrigon.c"
 #include "ftutil.c"
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include "ftinf.c"
+#endif
 
 
 /* END */
diff -Nur freetype-2.8/src/base/ftinf.c freetype-2.8.compiles-with-mactype/src/base/ftinf.c
--- freetype-2.8/src/base/ftinf.c	1969-12-31 18:00:00.000000000 -0600
+++ freetype-2.8.compiles-with-mactype/src/base/ftinf.c	2017-10-11 20:53:28.695653500 -0500
@@ -0,0 +1,363 @@
+#include <stdlib.h>
+#include "ftinf.h"
+#define true  1
+#define false 0
+
+#define on  1
+#define off 0
+#define end (-128)
+
+#define sw2pv 18  /* STEM_WIDTH_2_PPEM */
+#define maxp 100  /* MAX_PPEM */
+
+typedef signed char pv;         /* ppm and values type */
+/* the arrays start with existence flag + values */
+typedef struct sa_rules_s {
+    const char *name;
+    pv always_use_100[1+4+1];
+    pv brightness[1+2+1];
+    pv contrast[1+2+1];
+    pv edge_detection[1+4+1];
+    pv m[1+4+1];
+    pv bearing_correction[1+2+1];
+    pv spacing[1+5+1];
+    pv start[1+5+1];
+    pv stem_scaling[1+6+1];
+    pv stem_translating[1+2+1];
+    pv stem_translating_only[1+10+1];
+    pv stem_widths[1+4];        /* these end with maxp */
+    pv synthesize_stems[1+2+1];
+} sa_rules_t;
+
+#pragma GCC diagnostic ignored "-Wpedantic" /* C99 struct initializer tags are needed */
+#pragma GCC diagnostic ignored "-Wunused-function"
+
+const ftinf_t *ftinf;
+/* final settings, updated from environment */
+ftinf_t _env;
+
+/* rules and hashing function */
+#include "ftinf_rh.c"
+
+/* rules selection */
+void ftinf_fill_stem_values( Stem_Data *stem_values,
+                             const char *family, int ppem, int use_known ){
+    /* set the defaults */
+    stem_values->bearing_correction = TRUE;
+    stem_values->brightness = 0.0;
+    stem_values->contrast = 0.0;
+    stem_values->edge_detection = FALSE;
+    stem_values->m = -1;
+    stem_values->stem_scaling = -1;
+    stem_values->stem_spacing = -1;
+    stem_values->stem_start = -1;
+    stem_values->stem_translating = 0;
+    stem_values->stem_translating_only = -1024;
+    stem_values->stem_width = -1;
+    stem_values->synth_stems = FALSE;
+    stem_values->use_100 = FALSE;
+    /* pick from known rules if requested and they exist for current family */
+    if( !use_known )
+        return;
+    else {
+        const sa_rules_t *r=ftinf_rules( family );
+        int i;
+        if( r==NULL ) return;
+        if( r->stem_widths[0]==on )
+            for( i=1; r->stem_widths[i]!=maxp; ++i )
+                if( ppem < r->stem_widths[i] ){
+                    stem_values->stem_width = i-1;
+                    break;
+                }
+
+        if( r->stem_scaling[0]==on )
+            for( i=1; r->stem_scaling[i]!=end; i+=2 )
+                if( ppem==r->stem_scaling[i] ){
+                    stem_values->stem_scaling = r->stem_scaling[i+1];
+                    break;
+                }
+
+        if( r->m[0]==on )
+            for( i=1; r->m[i]!=end; i+=2 )
+                if( ppem==r->m[i] ){
+                    stem_values->m = r->m[i+1];
+                    break;
+                }
+
+        if( r->stem_translating_only[0]==on )
+            for( i=1; r->stem_translating_only[i]!=end; i+=2 )
+                if( ppem==r->stem_translating_only[i] || r->stem_translating_only[i]==0 ){
+                    stem_values->stem_translating_only = r->stem_translating_only[i+1];
+                    break;
+                }
+
+        if( r->stem_translating[0]==on )
+            for( i=1; r->stem_translating[i]!=end; i+=2 )
+                if( ppem==r->stem_translating[i] || r->stem_translating[i]==0 ){
+                    stem_values->stem_translating = r->stem_translating[i+1];
+                    break;
+                }
+
+        if( r->always_use_100[0]==on )
+            for( i=1; r->always_use_100[i]!=end; i+=2 )
+                if( ppem>=r->always_use_100[i] && ppem<=r->always_use_100[i+1] ){
+                    stem_values->use_100 = TRUE;
+                    break;
+                }
+
+        if( r->synthesize_stems[0]==on )
+            for( i=1; r->synthesize_stems[i]!=end; i+=2 )
+                if( ppem>=r->synthesize_stems[i] && ppem<=r->synthesize_stems[i+1] ){
+                    stem_values->synth_stems = TRUE;
+                    break;
+                }
+
+        if( r->edge_detection[0]==on )
+            for( i=1; r->edge_detection[i]!=end; i+=2 )
+                if( ppem>=r->edge_detection[i] && ppem<=r->edge_detection[i+1] ){
+                    stem_values->edge_detection = TRUE;
+                    break;
+                }
+
+        if( r->bearing_correction[0]==on )
+            for( i=1; r->bearing_correction[i]!=end; i+=2 )
+                if( ppem>=r->bearing_correction[i] && ppem<=r->bearing_correction[i+1] ){
+                    stem_values->bearing_correction = FALSE;
+                    break;
+                }
+
+#if(0)
+        if( r->brightness[0]==on )
+            for( i=1; r->brightness[i]!=end; i+=2 )
+                if( ppem==r->brightness[i]||r->brightness[i]==0 ){
+                    stem_values->brightness=r->brightness[i+1]*(1.0f/300.0f);
+                    break;
+                }
+
+        if( r->contrast[0]==on )
+            for( i=1; r->contrast[i]!=end; i+=2 )
+                if( ppem==r->contrast[i]||r->contrast[i]==0 ){
+                    stem_values->contrast=r->contrast[i+1]*(1.0f/300.0f);
+                    break;
+                }
+        if( r->spacing[0]==on ){
+            /* not used by original code */
+        }
+        if( r->start[0]==on ){
+            /* not used by original code */
+        }
+#endif
+    }
+    return;
+}
+
+void ftinf_get_bc( const char *family, int ppem, float *brightness, float *contrast ){
+    const sa_rules_t *r=ftinf_rules( family );
+    *brightness=0;
+    *contrast=0;
+    if( r ){
+        int i;
+        if( r->brightness[0]==on )
+            for( i=1; r->brightness[i]!=end; i+=2 )
+                if( ppem==r->brightness[i]||r->brightness[i]==0 ){
+                    *brightness=r->brightness[i+1]*(1.0f/300.0f);
+                    break;
+                }
+
+        if( r->contrast[0]==on )
+            for( i=1; r->contrast[i]!=end; i+=2 )
+                if( ppem==r->contrast[i]||r->contrast[i]==0 ){
+                    *contrast=r->contrast[i+1]*(1.0f/300.0f);
+                    break;
+                }
+    }
+    return;
+}
+
+static int
+bool_val( const char *s ){
+    if ( s != NULL )
+        return _stricmp(s, "true") == 0
+            || _stricmp(s, "1") == 0
+            || _stricmp(s, "on") == 0
+            || _stricmp(s, "yes") ==0;
+    else
+        return 0;
+}
+
+static int
+int_val( const char *s, int min, int max ){
+    int val;
+    sscanf ( s, "%d", &val );
+    if ( val > max )
+        val = max;
+    else if ( val < min )
+        val = min;
+    return val;
+}
+
+/* settings and hashing function */
+#include "ftinf_sh.c"
+
+/*
+  Get active Infinality settings
+ */
+void ftinf_env(){
+    const char *s;
+    ftinf=ftinf_settings( getenv( "INFINALITY_FT" ) );
+
+    if( ftinf==NULL ){
+        ftinf=ftinf_settings( "ultimate3" );
+        /* this should always succeed */
+#if(0)
+        if( ftinf==NULL ){
+            /* put an error here */
+            exit(-1);
+        }
+#endif
+    }
+    _env=ftinf[0];      /* copy as defaults */
+
+    /* check if custom environment values are set and update with them */
+    s=getenv( "INFINALITY_FT_AUTOHINT_INCREASE_GLYPH_HEIGHTS" );
+    if( s ) _env.autohint_increase_glyph_heights=bool_val( s );
+    s=getenv( "INFINALITY_FT_AUTOHINT_SNAP_STEM_HEIGHT" );
+    if( s ) _env.autohint_snap_stem_height=int_val( s, 0, 100 );
+    s=getenv( "INFINALITY_FT_USE_VARIOUS_TWEAKS" );
+    if( s ) _env.use_various_tweaks=bool_val( s );
+    s=getenv( "INFINALITY_FT_USE_KNOWN_SETTINGS_ON_SELECTED_FONTS" );
+    if( s ) _env.use_known_settings_on_selected_fonts=bool_val(s);
+#if(0)                          /* not used (naming error also) */
+    s=getenv( "INFINALITY_FT_AUTOHINT_MINIMUM_STEM_WIDTH" );
+    if( s ) _env.autohint_minimum_stem_height=int_val( s, 0, 100 );
+#endif
+    s=getenv( "INFINALITY_FT_STEM_SNAPPING_SLIDING_SCALE" );
+    if( s ) sscanf( s, "%d", &_env.stem_snapping_sliding_scale );
+    s=getenv( "INFINALITY_FT_STEM_ALIGNMENT_STRENGTH" );
+    if( s ) sscanf( s, "%d", &_env.stem_alignment_strength );
+    s=getenv( "INFINALITY_FT_STEM_DARKENING_AUTOFIT" );
+    if( s ) _env.stem_darkening_autofit=bool_val( s );
+    s=getenv( "INFINALITY_FT_STEM_DARKENING_CFF" );
+    if( s ) _env.stem_darkening_cff=bool_val( s );
+    s=getenv( "INFINALITY_FT_STEM_FITTING_STRENGTH" );
+    if( s ) sscanf( s, "%d", &_env.stem_fitting_strength );
+    s=getenv( "INFINALITY_FT_CHROMEOS_STYLE_SHARPENING_STRENGTH" );
+    if( s ) _env.chromeos_style_sharpening_strength=int_val( s, 0, 100 );
+    s=getenv( "INFINALITY_FT_BRIGHTNESS" );
+    if( s ) sscanf( s, "%d", &_env.brightness );
+    s=getenv( "INFINALITY_FT_CONTRAST" );
+    if( s ) sscanf( s, "%d", &_env.contrast );
+    s=getenv( "INFINALITY_FT_WINDOWS_STYLE_SHARPENING_STRENGTH" );
+    if( s ) _env.windows_style_sharpening_strength=int_val( s, 0, 100 );
+    s=getenv( "INFINALITY_FT_GAMMA_CORRECTION" );
+    if( s ){
+        float *f=_env.gamma_correction;
+        sscanf ( s, "%f %f", &f[0], &f[1] );
+        if( f[1] < 1.0f ) f[1]=1.0f;
+    }
+    s=getenv( "INFINALITY_FT_FRINGE_FILTER_STRENGTH" );
+    if( s ) sscanf( s, "%d", &_env.fringe_filter_strength );
+    s=getenv( "INFINALITY_FT_GRAYSCALE_FILTER_STRENGTH" );
+    if( s ) sscanf( s, "%d", &_env.grayscale_filter_strength );
+    s=getenv( "INFINALITY_FT_AUTOHINT_HORIZONTAL_STEM_DARKEN_STRENGTH" );
+    if( s ) sscanf( s, "%d", &_env.autohint_horizontal_stem_darken_strength );
+    s=getenv( "INFINALITY_FT_AUTOHINT_VERTICAL_STEM_DARKEN_STRENGTH" );
+    if( s ) sscanf( s, "%d", &_env.autohint_vertical_stem_darken_strength );
+    s=getenv( "INFINALITY_FT_GLOBAL_EMBOLDEN_X_VALUE" );
+    if( s ) sscanf( s, "%d", &_env.global_embolden_x_value );
+    s=getenv( "INFINALITY_FT_GLOBAL_EMBOLDEN_Y_VALUE" );
+    if( s ) sscanf( s, "%d", &_env.global_embolden_y_value );
+    s=getenv( "INFINALITY_FT_BOLD_EMBOLDEN_X_VALUE" );
+    if( s ) sscanf( s, "%d", &_env.bold_embolden_x_value );
+    s=getenv( "INFINALITY_FT_BOLD_EMBOLDEN_Y_VALUE" );
+    if( s ) sscanf( s, "%d", &_env.bold_embolden_y_value );
+    s=getenv( "INFINALITY_FT_FILTER_PARAMS" );
+    if( s ) {
+        int *f=_env.filter_params;
+        if( sscanf( s, "%d %d %d %d %d", f+1, f+2, f+3, f+4, f+5 )==5 )
+            f[0]=on;
+        else
+            f[0]=off;           /* FIXME: put a warning? */
+    }
+    /* do the range verifications as in original code */
+    if ( _env.stem_snapping_sliding_scale > maxp )
+        _env.stem_snapping_sliding_scale = 0;
+    else if ( _env.stem_snapping_sliding_scale < 0 )
+        _env.stem_snapping_sliding_scale = 0;
+    if (_env.stem_snapping_sliding_scale < 11 &&
+        _env.stem_snapping_sliding_scale > 0  )
+        _env.stem_snapping_sliding_scale = 11;
+
+    if ( _env.stem_alignment_strength > 100 )
+        _env.stem_alignment_strength = 100;
+    else if ( _env.stem_alignment_strength < 0 )
+        _env.stem_alignment_strength = 0;
+
+    if ( _env.stem_fitting_strength > 100 )
+        _env.stem_fitting_strength = 100;
+    else if ( _env.stem_fitting_strength < 0 )
+        _env.stem_fitting_strength = 0;
+
+    if ( _env.chromeos_style_sharpening_strength > 100 )
+        _env.chromeos_style_sharpening_strength = 100;
+    else if ( _env.chromeos_style_sharpening_strength < 0 )
+        _env.chromeos_style_sharpening_strength = 0;
+
+    if ( _env.brightness > 100 )
+        _env.brightness = 100;
+    else if ( _env.brightness < -100 )
+        _env.brightness = 0;
+
+    if ( _env.contrast > 100 )
+        _env.contrast = 100;
+    else if ( _env.contrast < -100 )
+        _env.contrast = 0;
+
+    if ( _env.windows_style_sharpening_strength > 100 )
+        _env.windows_style_sharpening_strength = 100;
+    else if ( _env.windows_style_sharpening_strength < 0 )
+        _env.windows_style_sharpening_strength = 0;
+
+    if ( _env.fringe_filter_strength > 100 )
+        _env.fringe_filter_strength = 100;
+    else if ( _env.fringe_filter_strength < 0 )
+        _env.fringe_filter_strength = 0;
+
+    if ( _env.grayscale_filter_strength > 100 )
+        _env.grayscale_filter_strength = 100;
+    else if ( _env.grayscale_filter_strength < 0 )
+        _env.grayscale_filter_strength = 0;
+
+    if ( _env.autohint_horizontal_stem_darken_strength > 100 )
+        _env.autohint_horizontal_stem_darken_strength = 100;
+    else if ( _env.autohint_horizontal_stem_darken_strength < 0 )
+        _env.autohint_horizontal_stem_darken_strength = 0;
+
+    if ( _env.autohint_vertical_stem_darken_strength > 100 )
+        _env.autohint_vertical_stem_darken_strength = 100;
+    else if ( _env.autohint_horizontal_stem_darken_strength < 0 )
+        _env.autohint_vertical_stem_darken_strength = 0;
+
+    if ( _env.global_embolden_x_value > 128 )
+        _env.global_embolden_x_value = 128;
+    else if ( _env.global_embolden_x_value < -128 )
+        _env.global_embolden_x_value = -128;
+
+    if ( _env.global_embolden_y_value > 128 )
+        _env.global_embolden_y_value = 128;
+    else if ( _env.global_embolden_y_value < -128 )
+          _env.global_embolden_y_value = -128;
+
+    if ( _env.bold_embolden_x_value > 128 )
+        _env.bold_embolden_x_value = 128;
+    else if (_env.bold_embolden_x_value < -128 )
+        _env.bold_embolden_x_value = -128;
+
+    if ( _env.bold_embolden_y_value > 128 )
+        _env.bold_embolden_y_value = 128;
+    else if ( _env.bold_embolden_y_value < -128 )
+        _env.bold_embolden_y_value = -128;
+
+    /* point to the combined and checked settings */
+    ftinf=&_env;
+}
diff -Nur freetype-2.8/src/base/ftinf.c.bak freetype-2.8.compiles-with-mactype/src/base/ftinf.c.bak
--- freetype-2.8/src/base/ftinf.c.bak	1969-12-31 18:00:00.000000000 -0600
+++ freetype-2.8.compiles-with-mactype/src/base/ftinf.c.bak	2017-10-09 19:43:58.964297600 -0500
@@ -0,0 +1,363 @@
+#include <stdlib.h>
+#include "ftinf.h"
+#define true  1
+#define false 0
+
+#define on  1
+#define off 0
+#define end (-128)
+
+#define sw2pv 18  /* STEM_WIDTH_2_PPEM */
+#define maxp 100  /* MAX_PPEM */
+
+typedef signed char pv;         /* ppm and values type */
+/* the arrays start with existence flag + values */
+typedef struct sa_rules_s {
+    const char *name;
+    pv always_use_100[1+4+1];
+    pv brightness[1+2+1];
+    pv contrast[1+2+1];
+    pv edge_detection[1+4+1];
+    pv m[1+4+1];
+    pv bearing_correction[1+2+1];
+    pv spacing[1+5+1];
+    pv start[1+5+1];
+    pv stem_scaling[1+6+1];
+    pv stem_translating[1+2+1];
+    pv stem_translating_only[1+10+1];
+    pv stem_widths[1+4];        /* these end with maxp */
+    pv synthesize_stems[1+2+1];
+} sa_rules_t;
+
+#pragma GCC diagnostic ignored "-Wpedantic" /* C99 struct initializer tags are needed */
+#pragma GCC diagnostic ignored "-Wunused-function"
+
+const ftinf_t *ftinf;
+/* final settings, updated from environment */
+ftinf_t _env;
+
+/* rules and hashing function */
+#include "ftinf_rh.c"
+
+/* rules selection */
+void ftinf_fill_stem_values( Stem_Data *stem_values,
+                             const char *family, int ppem, int use_known ){
+    /* set the defaults */
+    stem_values->bearing_correction = TRUE;
+    stem_values->brightness = 0.0;
+    stem_values->contrast = 0.0;
+    stem_values->edge_detection = FALSE;
+    stem_values->m = -1;
+    stem_values->stem_scaling = -1;
+    stem_values->stem_spacing = -1;
+    stem_values->stem_start = -1;
+    stem_values->stem_translating = 0;
+    stem_values->stem_translating_only = -1024;
+    stem_values->stem_width = -1;
+    stem_values->synth_stems = FALSE;
+    stem_values->use_100 = FALSE;
+    /* pick from known rules if requested and they exist for current family */
+    if( !use_known )
+        return;
+    else {
+        const sa_rules_t *r=ftinf_rules( family );
+        int i;
+        if( r==NULL ) return;
+        if( r->stem_widths[0]==on )
+            for( i=1; r->stem_widths[i]!=maxp; ++i )
+                if( ppem < r->stem_widths[i] ){
+                    stem_values->stem_width = i-1;
+                    break;
+                }
+
+        if( r->stem_scaling[0]==on )
+            for( i=1; r->stem_scaling[i]!=end; i+=2 )
+                if( ppem==r->stem_scaling[i] ){
+                    stem_values->stem_scaling = r->stem_scaling[i+1];
+                    break;
+                }
+
+        if( r->m[0]==on )
+            for( i=1; r->m[i]!=end; i+=2 )
+                if( ppem==r->m[i] ){
+                    stem_values->m = r->m[i+1];
+                    break;
+                }
+
+        if( r->stem_translating_only[0]==on )
+            for( i=1; r->stem_translating_only[i]!=end; i+=2 )
+                if( ppem==r->stem_translating_only[i] || r->stem_translating_only[i]==0 ){
+                    stem_values->stem_translating_only = r->stem_translating_only[i+1];
+                    break;
+                }
+
+        if( r->stem_translating[0]==on )
+            for( i=1; r->stem_translating[i]!=end; i+=2 )
+                if( ppem==r->stem_translating[i] || r->stem_translating[i]==0 ){
+                    stem_values->stem_translating = r->stem_translating[i+1];
+                    break;
+                }
+
+        if( r->always_use_100[0]==on )
+            for( i=1; r->always_use_100[i]!=end; i+=2 )
+                if( ppem>=r->always_use_100[i] && ppem<=r->always_use_100[i+1] ){
+                    stem_values->use_100 = TRUE;
+                    break;
+                }
+
+        if( r->synthesize_stems[0]==on )
+            for( i=1; r->synthesize_stems[i]!=end; i+=2 )
+                if( ppem>=r->synthesize_stems[i] && ppem<=r->synthesize_stems[i+1] ){
+                    stem_values->synth_stems = TRUE;
+                    break;
+                }
+
+        if( r->edge_detection[0]==on )
+            for( i=1; r->edge_detection[i]!=end; i+=2 )
+                if( ppem>=r->edge_detection[i] && ppem<=r->edge_detection[i+1] ){
+                    stem_values->edge_detection = TRUE;
+                    break;
+                }
+
+        if( r->bearing_correction[0]==on )
+            for( i=1; r->bearing_correction[i]!=end; i+=2 )
+                if( ppem>=r->bearing_correction[i] && ppem<=r->bearing_correction[i+1] ){
+                    stem_values->bearing_correction = FALSE;
+                    break;
+                }
+
+#if(0)
+        if( r->brightness[0]==on )
+            for( i=1; r->brightness[i]!=end; i+=2 )
+                if( ppem==r->brightness[i]||r->brightness[i]==0 ){
+                    stem_values->brightness=r->brightness[i+1]*(1.0f/300.0f);
+                    break;
+                }
+
+        if( r->contrast[0]==on )
+            for( i=1; r->contrast[i]!=end; i+=2 )
+                if( ppem==r->contrast[i]||r->contrast[i]==0 ){
+                    stem_values->contrast=r->contrast[i+1]*(1.0f/300.0f);
+                    break;
+                }
+        if( r->spacing[0]==on ){
+            /* not used by original code */
+        }
+        if( r->start[0]==on ){
+            /* not used by original code */
+        }
+#endif
+    }
+    return;
+}
+
+void ftinf_get_bc( const char *family, int ppem, float *brightness, float *contrast ){
+    const sa_rules_t *r=ftinf_rules( family );
+    *brightness=0;
+    *contrast=0;
+    if( r ){
+        int i;
+        if( r->brightness[0]==on )
+            for( i=1; r->brightness[i]!=end; i+=2 )
+                if( ppem==r->brightness[i]||r->brightness[i]==0 ){
+                    *brightness=r->brightness[i+1]*(1.0f/300.0f);
+                    break;
+                }
+
+        if( r->contrast[0]==on )
+            for( i=1; r->contrast[i]!=end; i+=2 )
+                if( ppem==r->contrast[i]||r->contrast[i]==0 ){
+                    *contrast=r->contrast[i+1]*(1.0f/300.0f);
+                    break;
+                }
+    }
+    return;
+}
+
+static int
+bool_val( const char *s ){
+    if ( s != NULL )
+        return strcasecmp(s, "true") == 0
+            || strcasecmp(s, "1") == 0
+            || strcasecmp(s, "on") == 0
+            || strcasecmp(s, "yes") ==0;
+    else
+        return 0;
+}
+
+static int
+int_val( const char *s, int min, int max ){
+    int val;
+    sscanf ( s, "%d", &val );
+    if ( val > max )
+        val = max;
+    else if ( val < min )
+        val = min;
+    return val;
+}
+
+/* settings and hashing function */
+#include "ftinf_sh.c"
+
+/*
+  Get active Infinality settings
+ */
+void ftinf_env(){
+    const char *s;
+    ftinf=ftinf_settings( getenv( "INFINALITY_FT" ) );
+
+    if( ftinf==NULL ){
+        ftinf=ftinf_settings( "ultimate3" );
+        /* this should always succeed */
+#if(0)
+        if( ftinf==NULL ){
+            /* put an error here */
+            exit(-1);
+        }
+#endif
+    }
+    _env=ftinf[0];      /* copy as defaults */
+
+    /* check if custom environment values are set and update with them */
+    s=getenv( "INFINALITY_FT_AUTOHINT_INCREASE_GLYPH_HEIGHTS" );
+    if( s ) _env.autohint_increase_glyph_heights=bool_val( s );
+    s=getenv( "INFINALITY_FT_AUTOHINT_SNAP_STEM_HEIGHT" );
+    if( s ) _env.autohint_snap_stem_height=int_val( s, 0, 100 );
+    s=getenv( "INFINALITY_FT_USE_VARIOUS_TWEAKS" );
+    if( s ) _env.use_various_tweaks=bool_val( s );
+    s=getenv( "INFINALITY_FT_USE_KNOWN_SETTINGS_ON_SELECTED_FONTS" );
+    if( s ) _env.use_known_settings_on_selected_fonts=bool_val(s);
+#if(0)                          /* not used (naming error also) */
+    s=getenv( "INFINALITY_FT_AUTOHINT_MINIMUM_STEM_WIDTH" );
+    if( s ) _env.autohint_minimum_stem_height=int_val( s, 0, 100 );
+#endif
+    s=getenv( "INFINALITY_FT_STEM_SNAPPING_SLIDING_SCALE" );
+    if( s ) sscanf( s, "%d", &_env.stem_snapping_sliding_scale );
+    s=getenv( "INFINALITY_FT_STEM_ALIGNMENT_STRENGTH" );
+    if( s ) sscanf( s, "%d", &_env.stem_alignment_strength );
+    s=getenv( "INFINALITY_FT_STEM_DARKENING_AUTOFIT" );
+    if( s ) _env.stem_darkening_autofit=bool_val( s );
+    s=getenv( "INFINALITY_FT_STEM_DARKENING_CFF" );
+    if( s ) _env.stem_darkening_cff=bool_val( s );
+    s=getenv( "INFINALITY_FT_STEM_FITTING_STRENGTH" );
+    if( s ) sscanf( s, "%d", &_env.stem_fitting_strength );
+    s=getenv( "INFINALITY_FT_CHROMEOS_STYLE_SHARPENING_STRENGTH" );
+    if( s ) _env.chromeos_style_sharpening_strength=int_val( s, 0, 100 );
+    s=getenv( "INFINALITY_FT_BRIGHTNESS" );
+    if( s ) sscanf( s, "%d", &_env.brightness );
+    s=getenv( "INFINALITY_FT_CONTRAST" );
+    if( s ) sscanf( s, "%d", &_env.contrast );
+    s=getenv( "INFINALITY_FT_WINDOWS_STYLE_SHARPENING_STRENGTH" );
+    if( s ) _env.windows_style_sharpening_strength=int_val( s, 0, 100 );
+    s=getenv( "INFINALITY_FT_GAMMA_CORRECTION" );
+    if( s ){
+        float *f=_env.gamma_correction;
+        sscanf ( s, "%f %f", &f[0], &f[1] );
+        if( f[1] < 1.0f ) f[1]=1.0f;
+    }
+    s=getenv( "INFINALITY_FT_FRINGE_FILTER_STRENGTH" );
+    if( s ) sscanf( s, "%d", &_env.fringe_filter_strength );
+    s=getenv( "INFINALITY_FT_GRAYSCALE_FILTER_STRENGTH" );
+    if( s ) sscanf( s, "%d", &_env.grayscale_filter_strength );
+    s=getenv( "INFINALITY_FT_AUTOHINT_HORIZONTAL_STEM_DARKEN_STRENGTH" );
+    if( s ) sscanf( s, "%d", &_env.autohint_horizontal_stem_darken_strength );
+    s=getenv( "INFINALITY_FT_AUTOHINT_VERTICAL_STEM_DARKEN_STRENGTH" );
+    if( s ) sscanf( s, "%d", &_env.autohint_vertical_stem_darken_strength );
+    s=getenv( "INFINALITY_FT_GLOBAL_EMBOLDEN_X_VALUE" );
+    if( s ) sscanf( s, "%d", &_env.global_embolden_x_value );
+    s=getenv( "INFINALITY_FT_GLOBAL_EMBOLDEN_Y_VALUE" );
+    if( s ) sscanf( s, "%d", &_env.global_embolden_y_value );
+    s=getenv( "INFINALITY_FT_BOLD_EMBOLDEN_X_VALUE" );
+    if( s ) sscanf( s, "%d", &_env.bold_embolden_x_value );
+    s=getenv( "INFINALITY_FT_BOLD_EMBOLDEN_Y_VALUE" );
+    if( s ) sscanf( s, "%d", &_env.bold_embolden_y_value );
+    s=getenv( "INFINALITY_FT_FILTER_PARAMS" );
+    if( s ) {
+        int *f=_env.filter_params;
+        if( sscanf( s, "%d %d %d %d %d", f+1, f+2, f+3, f+4, f+5 )==5 )
+            f[0]=on;
+        else
+            f[0]=off;           /* FIXME: put a warning? */
+    }
+    /* do the range verifications as in original code */
+    if ( _env.stem_snapping_sliding_scale > maxp )
+        _env.stem_snapping_sliding_scale = 0;
+    else if ( _env.stem_snapping_sliding_scale < 0 )
+        _env.stem_snapping_sliding_scale = 0;
+    if (_env.stem_snapping_sliding_scale < 11 &&
+        _env.stem_snapping_sliding_scale > 0  )
+        _env.stem_snapping_sliding_scale = 11;
+
+    if ( _env.stem_alignment_strength > 100 )
+        _env.stem_alignment_strength = 100;
+    else if ( _env.stem_alignment_strength < 0 )
+        _env.stem_alignment_strength = 0;
+
+    if ( _env.stem_fitting_strength > 100 )
+        _env.stem_fitting_strength = 100;
+    else if ( _env.stem_fitting_strength < 0 )
+        _env.stem_fitting_strength = 0;
+
+    if ( _env.chromeos_style_sharpening_strength > 100 )
+        _env.chromeos_style_sharpening_strength = 100;
+    else if ( _env.chromeos_style_sharpening_strength < 0 )
+        _env.chromeos_style_sharpening_strength = 0;
+
+    if ( _env.brightness > 100 )
+        _env.brightness = 100;
+    else if ( _env.brightness < -100 )
+        _env.brightness = 0;
+
+    if ( _env.contrast > 100 )
+        _env.contrast = 100;
+    else if ( _env.contrast < -100 )
+        _env.contrast = 0;
+
+    if ( _env.windows_style_sharpening_strength > 100 )
+        _env.windows_style_sharpening_strength = 100;
+    else if ( _env.windows_style_sharpening_strength < 0 )
+        _env.windows_style_sharpening_strength = 0;
+
+    if ( _env.fringe_filter_strength > 100 )
+        _env.fringe_filter_strength = 100;
+    else if ( _env.fringe_filter_strength < 0 )
+        _env.fringe_filter_strength = 0;
+
+    if ( _env.grayscale_filter_strength > 100 )
+        _env.grayscale_filter_strength = 100;
+    else if ( _env.grayscale_filter_strength < 0 )
+        _env.grayscale_filter_strength = 0;
+
+    if ( _env.autohint_horizontal_stem_darken_strength > 100 )
+        _env.autohint_horizontal_stem_darken_strength = 100;
+    else if ( _env.autohint_horizontal_stem_darken_strength < 0 )
+        _env.autohint_horizontal_stem_darken_strength = 0;
+
+    if ( _env.autohint_vertical_stem_darken_strength > 100 )
+        _env.autohint_vertical_stem_darken_strength = 100;
+    else if ( _env.autohint_horizontal_stem_darken_strength < 0 )
+        _env.autohint_vertical_stem_darken_strength = 0;
+
+    if ( _env.global_embolden_x_value > 128 )
+        _env.global_embolden_x_value = 128;
+    else if ( _env.global_embolden_x_value < -128 )
+        _env.global_embolden_x_value = -128;
+
+    if ( _env.global_embolden_y_value > 128 )
+        _env.global_embolden_y_value = 128;
+    else if ( _env.global_embolden_y_value < -128 )
+          _env.global_embolden_y_value = -128;
+
+    if ( _env.bold_embolden_x_value > 128 )
+        _env.bold_embolden_x_value = 128;
+    else if (_env.bold_embolden_x_value < -128 )
+        _env.bold_embolden_x_value = -128;
+
+    if ( _env.bold_embolden_y_value > 128 )
+        _env.bold_embolden_y_value = 128;
+    else if ( _env.bold_embolden_y_value < -128 )
+        _env.bold_embolden_y_value = -128;
+
+    /* point to the combined and checked settings */
+    ftinf=&_env;
+}
diff -Nur freetype-2.8/src/base/ftinf.h freetype-2.8.compiles-with-mactype/src/base/ftinf.h
--- freetype-2.8/src/base/ftinf.h	1969-12-31 18:00:00.000000000 -0600
+++ freetype-2.8.compiles-with-mactype/src/base/ftinf.h	2017-10-09 19:43:58.966299800 -0500
@@ -0,0 +1,66 @@
+#ifndef _FTINF_H_
+#define _FTINF_H_
+/*
+    Stem snapping rules
+    (base freetype typedefs assumed already included)
+ */
+typedef struct
+{
+    FT_Int       stem_width;
+    FT_Int       stem_spacing;
+    FT_Int       stem_start;
+    FT_Int       stem_scaling;
+    FT_Int       stem_translating_only;
+    FT_Int       stem_translating;
+    float        brightness;
+    float        contrast;
+    FT_Bool      use_100;
+    FT_Bool      synth_stems;
+    FT_Bool      edge_detection;
+    FT_Bool      bearing_correction;
+    FT_Int       m;
+} Stem_Data;
+
+/*
+  Infinality settings
+ */
+typedef struct ftinf_s {
+    const char *name;
+    int autohint_horizontal_stem_darken_strength;
+    int autohint_snap_stem_height;
+    int autohint_increase_glyph_heights;
+    int autohint_vertical_stem_darken_strength;
+    int bold_embolden_x_value;
+    int bold_embolden_y_value;
+    int brightness;
+    int chromeos_style_sharpening_strength;
+    int contrast;
+    int filter_params[6];       /* 1st one used as existence flag */
+    int fringe_filter_strength;
+    float gamma_correction[2];
+    int global_embolden_x_value;
+    int global_embolden_y_value;
+    int grayscale_filter_strength;
+    int stem_alignment_strength;
+    int stem_darkening_autofit;
+    int stem_darkening_cff;
+    int stem_fitting_strength;
+    int stem_snapping_sliding_scale;
+    int use_known_settings_on_selected_fonts;
+    int use_various_tweaks;
+    int windows_style_sharpening_strength;
+} ftinf_t;
+
+extern FT_Pos infinality_cur_width; /* defined in aflatin.c */
+
+extern const ftinf_t *ftinf;    /* active settings */
+
+extern void ftinf_fill_stem_values( Stem_Data *stem_values,
+                                    const char *family, int ppem, int use_known );
+extern void ftinf_get_bc( const char *family, int ppem,
+                          float *brightness, float *contrast );
+
+/* get values from environment (FIXME: maybe update with using user files) */
+extern void ftinf_env();
+
+#endif
diff -Nur freetype-2.8/src/base/ftinf_rh.c freetype-2.8.compiles-with-mactype/src/base/ftinf_rh.c
--- freetype-2.8/src/base/ftinf_rh.c	1969-12-31 18:00:00.000000000 -0600
+++ freetype-2.8.compiles-with-mactype/src/base/ftinf_rh.c	2017-10-09 19:43:58.969302800 -0500
@@ -0,0 +1,626 @@
+/* ANSI-C code produced by gperf version 3.1 */
+/* Command-line: gperf --output-file=ftinf_rh.c ftinf_rh.gperf  */
+/* Computed positions: -k'1,$' */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+#line 9 "ftinf_rh.gperf"
+
+#include <ctype.h>
+static const struct sa_rules_s* _rules_get( const char*str, unsigned len );
+/* maximum key range = 82, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+_rules_hash (register const char *str, register unsigned int len)
+{
+  static const unsigned char asso_values[] =
+    {
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85,  0, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85,  5, 45,  5,
+      35, 25, 35, 35, 50, 45, 85, 85,  0, 25,
+      40,  5,  0, 85, 50, 20, 20,  0, 10, 10,
+      85, 10, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85, 85, 85, 85, 85,
+      85, 85, 85, 85, 85, 85
+    };
+  return len + asso_values[(unsigned char)str[len - 1]] + asso_values[(unsigned char)str[0]];
+}
+
+#ifdef __GNUC__
+__inline
+#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
+#endif
+const struct sa_rules_s *
+_rules_get (register const char *str, register unsigned int len)
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 58,
+      MIN_WORD_LENGTH = 3,
+      MAX_WORD_LENGTH = 24,
+      MIN_HASH_VALUE = 3,
+      MAX_HASH_VALUE = 84
+    };
+
+  static const struct sa_rules_s wordlist[] =
+    {
+#line 15 "ftinf_rh.gperf"
+{   .name="---",
+    .synthesize_stems={on, 13, 13, end}
+},
+#line 253 "ftinf_rh.gperf"
+{   .name="ubuntu",
+    .always_use_100={on, 12, 13, 15, 15, end}
+},
+#line 31 "ftinf_rh.gperf"
+{   .name="arial",
+    .always_use_100={on, 0, maxp, end},
+    .edge_detection={on, 11, 11, 13, 13, end},
+    .spacing={on, 10, 11, 23, 25, 30, end},
+    .start={on, 11, 18, 23, 30, 30, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 16, 8, 32, 9, 32, 16, -24, end}
+},
+#line 87 "ftinf_rh.gperf"
+{   .name="corbel",
+    .stem_translating_only={on, 10, 16, end},
+    .stem_widths={on, 10, 21, maxp}
+},
+#line 71 "ftinf_rh.gperf"
+{   .name="canwell",
+    .stem_scaling={on, 13, 0, end}
+},
+#line 216 "ftinf_rh.gperf"
+{   .name="pragmata",
+    .always_use_100={on, 0, maxp, end}
+},
+#line 67 "ftinf_rh.gperf"
+{   .name="cantarell",
+    .stem_translating_only={on, 11, 0, 12, 0, end},
+    .stem_widths={on, 10, 22, maxp,}
+},
+#line 39 "ftinf_rh.gperf"
+{   .name="arimo",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 8, 8, 32, 9, 32, end}
+},
+#line 207 "ftinf_rh.gperf"
+{   .name="optima",
+    .brightness={on, 0, -20, end},
+    .contrast={on, 0, 25, end},
+    .stem_scaling={on, 17, 1, end},
+    .stem_translating_only={on, 10, 0, 11, 0, 12, 0, end}
+},
+#line 63 "ftinf_rh.gperf"
+{   .name="candara",
+    .stem_scaling={on, 14, 1, 17, 1, end},
+    .stem_translating_only={on, 10, 16, end}
+},
+#line 77 "ftinf_rh.gperf"
+{   .name="comfortaa",
+    .stem_widths={on, 10, 19, 22, maxp},
+    .stem_scaling={on, 11, 0, end}
+},
+#line 161 "ftinf_rh.gperf"
+{   .name="liberation mono",
+    .always_use_100={on, 0, maxp, end}
+},
+#line 18 "ftinf_rh.gperf"
+{   .name="andale mono",
+    .always_use_100={on, 0, maxp, end},
+    .stem_scaling={on, 11, 1, end},
+    .stem_widths={on, 10, 21, maxp,}
+},
+#line 256 "ftinf_rh.gperf"
+{   .name="verdana",
+    .always_use_100={on, 0, 14, 16, maxp, end},
+    .stem_scaling={on, 12, 1, 15, 1, end},
+    .stem_translating_only={on, 8, 16, 15, 16, 14, 32, 18, 32, 19, 24, end}
+},
+#line 74 "ftinf_rh.gperf"
+{   .name="century gothic",
+    .stem_widths={on, 10, 22, maxp,}
+},
+#line 91 "ftinf_rh.gperf"
+{   .name="courier new",
+    .always_use_100={on, 12, 12, end},
+    .edge_detection={on, 10, 12, end},
+    .m={on, 13, 1, 14, 1, end}
+},
+#line 23 "ftinf_rh.gperf"
+{   .name="arial narrow",
+    .stem_widths={on, 10, 21, maxp,}
+},
+#line 185 "ftinf_rh.gperf"
+{   .name="luxi sans",
+    .always_use_100={on, 13, 13, end},
+    .stem_widths={on, 10, 17, sw2pv, maxp,}
+},
+#line 225 "ftinf_rh.gperf"
+{   .name="samba",
+    .stem_scaling={on, 11, 0, end}
+},
+#line 233 "ftinf_rh.gperf"
+{   .name="tahoma",
+    .always_use_100={on, 11, 11, 14, maxp, end},
+    .edge_detection={on, 11, 11, end},
+    .spacing={on, 10, 12, 18, 18, 30, end},
+    .start={on, 14, 17, 30, 100, 100, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 7, 32, 8, 32, 9, 32, end},
+},
+#line 164 "ftinf_rh.gperf"
+{   .name="liberation sans narrow",
+    .stem_widths={on,10, 22, maxp,}
+},
+#line 81 "ftinf_rh.gperf"
+{   .name="consolas",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating_only={on, 8, 32, 9, 32, end},
+    .stem_widths={on, 10, 20, maxp,},
+    .stem_scaling={on, 11, 1, end}
+},
+#line 203 "ftinf_rh.gperf"
+{   .name="open sans",
+    .stem_translating_only={on, 10, 16, 9, 16, end},
+    .stem_widths={on, 10, 20, maxp,}
+},
+#line 167 "ftinf_rh.gperf"
+{   .name="liberation sans",
+    .edge_detection={on, 11, 11, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 8, 8, 32, 9, 32, end},
+    .stem_widths={on,10, 19, maxp,}
+},
+#line 193 "ftinf_rh.gperf"
+{   .name="monaco",
+    .always_use_100={on, 0, maxp, end}
+},
+#line 101 "ftinf_rh.gperf"
+{   .name="cousine",
+    .always_use_100={on, 0, maxp, end}
+},
+#line 176 "ftinf_rh.gperf"
+{   .name="lucida grande",
+    .stem_scaling={on, 13, 1, end},
+    .stem_translating_only={on, 13, 24, 14, 24, 8, 16, 9, 16, end},
+    .stem_widths={on, 10, 16, sw2pv, maxp},
+},
+#line 173 "ftinf_rh.gperf"
+{   .name="lucida console",
+    .always_use_100={on, 0, maxp, end}
+},
+#line 196 "ftinf_rh.gperf"
+{   .name="myriad pro",
+    .stem_scaling={on, 14, 1, 17, 1, end},
+    .stem_translating_only={on, 10, 16, 11, 0, 9, 16, end}
+},
+#line 26 "ftinf_rh.gperf"
+{   .name="arial unicode ms",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 16, 8, 32, 9, 32, end}
+},
+#line 213 "ftinf_rh.gperf"
+{   .name="palatino linotype",
+    .edge_detection={on, 0, 100, end}
+},
+#line 181 "ftinf_rh.gperf"
+{   .name="lucida sans unicode",
+    .stem_translating_only={on, 13, 24, 14, 24, 8, 16, 9, 16, end},
+    .stem_widths={on,10, 16, sw2pv, maxp,}
+},
+#line 140 "ftinf_rh.gperf"
+{   .name="futura",
+    .stem_widths={on, 10, 14, sw2pv, maxp,}
+},
+#line 147 "ftinf_rh.gperf"
+{   .name="georgia",
+    .stem_translating_only={on, 13, 16, 14, 16, 15, 0, end}
+},
+#line 125 "ftinf_rh.gperf"
+{   .name="freemono",
+    .always_use_100={on, 0, maxp, end}
+},
+#line 200 "ftinf_rh.gperf"
+{   .name="nina",
+    .stem_scaling={on, 11, 0, 12, 0, 13, 0, end}
+},
+#line 121 "ftinf_rh.gperf"
+{   .name="essential pragmatapro",
+    .always_use_100={on, 0, maxp, end},
+    .m={on, 13, 0, 14, 0, end}
+},
+#line 247 "ftinf_rh.gperf"
+{   .name="trebuchet ms",
+    .always_use_100={on, 13, 13, end},
+    .stem_scaling={on, 13, 0, 17, 0, 20, 1, end},
+    .stem_translating_only={on, 10, 16, 11, 0, 8, 32, 9, 32, end},
+    .stem_widths={on, 10, 17, sw2pv, maxp,}
+},
+#line 114 "ftinf_rh.gperf"
+{   .name="droid sans mono",
+    .m={on, 12, 0, end}
+},
+#line 104 "ftinf_rh.gperf"
+{   .name="dejavu sans mono",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating_only={on, 7, 16, 8, 32, 9, 16, end}
+},
+#line 57 "ftinf_rh.gperf"
+{   .name="calibri",
+    .always_use_100={on, 23, maxp, end},
+    .stem_scaling={on, 15, 1, 17, 1, 18, 1, end},
+    .stem_translating_only={on, 10, 16, 15, 0, end},
+    .stem_widths={on, 1, 10, 19, maxp,}
+},
+#line 156 "ftinf_rh.gperf"
+{   .name="inconsolata",
+    .stem_scaling={on, 12, 1, 15, 1, end},
+    .stem_translating_only={on, 10, 24, 9, 32, end},
+    .stem_widths={on, 10, 23, maxp,},
+},
+#line 96 "ftinf_rh.gperf"
+{   .name="courier",
+    .always_use_100={on, 0, maxp, end},
+    .m={on, 13, 1, 14, 1, end},
+    .stem_translating_only={on, 13, 16, 15, 0, end}
+},
+#line 128 "ftinf_rh.gperf"
+{   .name="freesans",
+    .always_use_100={on, 0, maxp, end},
+    .edge_detection={on, 11, 11, 13, 13, end},
+    .spacing={on, 10, 12, 18, 18, 30, end},
+    .start={on, 10, 18, 18, 25, 30, end},
+    .stem_scaling={on, 16, 0, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 16, 9, 8, end}
+},
+#line 150 "ftinf_rh.gperf"
+{   .name="gill sans",
+    .stem_widths={on, 10, 17, sw2pv, maxp,}
+},
+#line 117 "ftinf_rh.gperf"
+{   .name="droid sans",
+    .always_use_100={on, 12, 12, 15, 15, end},
+    .stem_translating_only={on, 8, 16, 9, 16, end}
+},
+#line 108 "ftinf_rh.gperf"
+{   .name="dejavu sans",
+    .always_use_100={on, 10, 14, 16, 17, end},
+    .m={on, 12, 0, end},
+    .stem_scaling={on, 12, 1, end},
+    .stem_translating_only={on, 8, 16, 15, -20, end}
+},
+#line 219 "ftinf_rh.gperf"
+{   .name="raleway",
+    .stem_scaling={on, 15, 0, end}
+},
+#line 153 "ftinf_rh.gperf"
+{   .name="helvetica cy",
+    .stem_widths={on, 10, 23, maxp,}
+},
+#line 228 "ftinf_rh.gperf"
+{   .name="segoe ui",
+    .always_use_100={on, 11, 12, 14, 14, end},
+    .stem_translating_only={on, 10, 0, 7, 32, 8, 16, 9, 24, end},
+    .stem_widths={on, 10, 23, maxp,}
+},
+#line 48 "ftinf_rh.gperf"
+{   .name="bitstream vera sans mono",
+    .always_use_100={on, 0, maxp, end}
+},
+#line 241 "ftinf_rh.gperf"
+{   .name="times new roman",
+    .always_use_100={on, 14, 14, 16, 16, end},
+    .bearing_correction={0, 100, end},
+    .stem_scaling={on, 17, 1, end},
+    .stem_translating_only={on, 17, 8, end}
+},
+#line 222 "ftinf_rh.gperf"
+{   .name="rokkitt",
+    .stem_widths={on, 10, 21, maxp,}
+},
+#line 143 "ftinf_rh.gperf"
+{   .name="garamond",
+    .brightness={on, 0, -20, end},
+    .contrast={on, 0, 25, end}
+},
+#line 137 "ftinf_rh.gperf"
+{   .name="freeserif",
+    .stem_scaling={on, 13, 1, 17, 1, end}
+},
+#line 189 "ftinf_rh.gperf"
+{   .name="microsoft sans serif",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating_only={on, 10, 16, 8, 32, 9, 32, end}
+},
+#line 44 "ftinf_rh.gperf"
+{   .name="baskerville",
+    .brightness={on, 0, -20, end},
+    .contrast={on, 0, 25, end}
+},
+#line 51 "ftinf_rh.gperf"
+{   .name="bitstream vera sans",
+    .always_use_100={on, 10, 14, 16, 17, end},
+    .m={on, 12, 0, end},
+    .stem_scaling={on ,12, 1, end},
+    .stem_translating_only={on, 8, 16, end}
+}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = _rules_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
+        {
+          register const struct sa_rules_s *resword;
+
+          switch (key - 3)
+            {
+              case 0:
+                resword = &wordlist[0];
+                goto compare;
+              case 3:
+                resword = &wordlist[1];
+                goto compare;
+              case 7:
+                resword = &wordlist[2];
+                goto compare;
+              case 8:
+                resword = &wordlist[3];
+                goto compare;
+              case 9:
+                resword = &wordlist[4];
+                goto compare;
+              case 10:
+                resword = &wordlist[5];
+                goto compare;
+              case 11:
+                resword = &wordlist[6];
+                goto compare;
+              case 12:
+                resword = &wordlist[7];
+                goto compare;
+              case 13:
+                resword = &wordlist[8];
+                goto compare;
+              case 14:
+                resword = &wordlist[9];
+                goto compare;
+              case 16:
+                resword = &wordlist[10];
+                goto compare;
+              case 17:
+                resword = &wordlist[11];
+                goto compare;
+              case 18:
+                resword = &wordlist[12];
+                goto compare;
+              case 19:
+                resword = &wordlist[13];
+                goto compare;
+              case 21:
+                resword = &wordlist[14];
+                goto compare;
+              case 23:
+                resword = &wordlist[15];
+                goto compare;
+              case 24:
+                resword = &wordlist[16];
+                goto compare;
+              case 26:
+                resword = &wordlist[17];
+                goto compare;
+              case 27:
+                resword = &wordlist[18];
+                goto compare;
+              case 28:
+                resword = &wordlist[19];
+                goto compare;
+              case 29:
+                resword = &wordlist[20];
+                goto compare;
+              case 30:
+                resword = &wordlist[21];
+                goto compare;
+              case 31:
+                resword = &wordlist[22];
+                goto compare;
+              case 32:
+                resword = &wordlist[23];
+                goto compare;
+              case 33:
+                resword = &wordlist[24];
+                goto compare;
+              case 34:
+                resword = &wordlist[25];
+                goto compare;
+              case 35:
+                resword = &wordlist[26];
+                goto compare;
+              case 36:
+                resword = &wordlist[27];
+                goto compare;
+              case 37:
+                resword = &wordlist[28];
+                goto compare;
+              case 38:
+                resword = &wordlist[29];
+                goto compare;
+              case 39:
+                resword = &wordlist[30];
+                goto compare;
+              case 41:
+                resword = &wordlist[31];
+                goto compare;
+              case 43:
+                resword = &wordlist[32];
+                goto compare;
+              case 44:
+                resword = &wordlist[33];
+                goto compare;
+              case 45:
+                resword = &wordlist[34];
+                goto compare;
+              case 46:
+                resword = &wordlist[35];
+                goto compare;
+              case 48:
+                resword = &wordlist[36];
+                goto compare;
+              case 49:
+                resword = &wordlist[37];
+                goto compare;
+              case 52:
+                resword = &wordlist[38];
+                goto compare;
+              case 53:
+                resword = &wordlist[39];
+                goto compare;
+              case 54:
+                resword = &wordlist[40];
+                goto compare;
+              case 58:
+                resword = &wordlist[41];
+                goto compare;
+              case 59:
+                resword = &wordlist[42];
+                goto compare;
+              case 60:
+                resword = &wordlist[43];
+                goto compare;
+              case 61:
+                resword = &wordlist[44];
+                goto compare;
+              case 62:
+                resword = &wordlist[45];
+                goto compare;
+              case 63:
+                resword = &wordlist[46];
+                goto compare;
+              case 64:
+                resword = &wordlist[47];
+                goto compare;
+              case 69:
+                resword = &wordlist[48];
+                goto compare;
+              case 70:
+                resword = &wordlist[49];
+                goto compare;
+              case 71:
+                resword = &wordlist[50];
+                goto compare;
+              case 72:
+                resword = &wordlist[51];
+                goto compare;
+              case 74:
+                resword = &wordlist[52];
+                goto compare;
+              case 75:
+                resword = &wordlist[53];
+                goto compare;
+              case 76:
+                resword = &wordlist[54];
+                goto compare;
+              case 77:
+                resword = &wordlist[55];
+                goto compare;
+              case 78:
+                resword = &wordlist[56];
+                goto compare;
+              case 81:
+                resword = &wordlist[57];
+                goto compare;
+            }
+          return 0;
+        compare:
+          {
+            register const char *s = resword->name;
+
+            if (*str == *s && !strcmp (str + 1, s + 1))
+              return resword;
+          }
+        }
+    }
+  return 0;
+}
+#line 261 "ftinf_rh.gperf"
+
+
+static const sa_rules_t*
+ftinf_rules( const char *name ){
+    if( name ){
+        enum {
+            max_wlen=31
+        };
+        char buf[max_wlen+1];
+        int len=strlen( name );
+        if( len <= max_wlen ){
+            int i;
+            for( i=0; i<len; ++i )
+                buf[i]=tolower( name[i] );
+            buf[len]='\0';
+            return _rules_get( buf, len );
+        }
+    }
+    return NULL;
+}
+/*
+   gperf --output-file=ftinf_rh.c ftinf_rh.gperf
+*/
diff -Nur freetype-2.8/src/base/ftinf_rh.gperf freetype-2.8.compiles-with-mactype/src/base/ftinf_rh.gperf
--- freetype-2.8/src/base/ftinf_rh.gperf	1969-12-31 18:00:00.000000000 -0600
+++ freetype-2.8.compiles-with-mactype/src/base/ftinf_rh.gperf	2017-10-09 19:43:58.971805000 -0500
@@ -0,0 +1,283 @@
+%struct-type
+%define slot-name name
+%enum
+%switch=1
+%readonly-tables
+%omit-struct-type
+%define lookup-function-name  _rules_get
+%define hash-function-name _rules_hash
+%{
+#include <ctype.h>
+static const struct sa_rules_s* _rules_get( const char*str, unsigned len );
+%}
+struct sa_rules_s;
+%%
+{   .name="---",
+    .synthesize_stems={on, 13, 13, end}
+},
+{   .name="andale mono",
+    .always_use_100={on, 0, maxp, end},
+    .stem_scaling={on, 11, 1, end},
+    .stem_widths={on, 10, 21, maxp,}
+},
+{   .name="arial narrow",
+    .stem_widths={on, 10, 21, maxp,}
+},
+{   .name="arial unicode ms",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 16, 8, 32, 9, 32, end}
+},
+{   .name="arial",
+    .always_use_100={on, 0, maxp, end},
+    .edge_detection={on, 11, 11, 13, 13, end},
+    .spacing={on, 10, 11, 23, 25, 30, end},
+    .start={on, 11, 18, 23, 30, 30, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 16, 8, 32, 9, 32, 16, -24, end}
+},
+{   .name="arimo",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 8, 8, 32, 9, 32, end}
+},
+{   .name="baskerville",
+    .brightness={on, 0, -20, end},
+    .contrast={on, 0, 25, end}
+},
+{   .name="bitstream vera sans mono",
+    .always_use_100={on, 0, maxp, end}
+},
+{   .name="bitstream vera sans",
+    .always_use_100={on, 10, 14, 16, 17, end},
+    .m={on, 12, 0, end},
+    .stem_scaling={on ,12, 1, end},
+    .stem_translating_only={on, 8, 16, end}
+},
+{   .name="calibri",
+    .always_use_100={on, 23, maxp, end},
+    .stem_scaling={on, 15, 1, 17, 1, 18, 1, end},
+    .stem_translating_only={on, 10, 16, 15, 0, end},
+    .stem_widths={on, 1, 10, 19, maxp,}
+},
+{   .name="candara",
+    .stem_scaling={on, 14, 1, 17, 1, end},
+    .stem_translating_only={on, 10, 16, end}
+},
+{   .name="cantarell",
+    .stem_translating_only={on, 11, 0, 12, 0, end},
+    .stem_widths={on, 10, 22, maxp,}
+},
+{   .name="canwell",
+    .stem_scaling={on, 13, 0, end}
+},
+{   .name="century gothic",
+    .stem_widths={on, 10, 22, maxp,}
+},
+{   .name="comfortaa",
+    .stem_widths={on, 10, 19, 22, maxp},
+    .stem_scaling={on, 11, 0, end}
+},
+{   .name="consolas",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating_only={on, 8, 32, 9, 32, end},
+    .stem_widths={on, 10, 20, maxp,},
+    .stem_scaling={on, 11, 1, end}
+},
+{   .name="corbel",
+    .stem_translating_only={on, 10, 16, end},
+    .stem_widths={on, 10, 21, maxp}
+},
+{   .name="courier new",
+    .always_use_100={on, 12, 12, end},
+    .edge_detection={on, 10, 12, end},
+    .m={on, 13, 1, 14, 1, end}
+},
+{   .name="courier",
+    .always_use_100={on, 0, maxp, end},
+    .m={on, 13, 1, 14, 1, end},
+    .stem_translating_only={on, 13, 16, 15, 0, end}
+},
+{   .name="cousine",
+    .always_use_100={on, 0, maxp, end}
+},
+{   .name="dejavu sans mono",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating_only={on, 7, 16, 8, 32, 9, 16, end}
+},
+{   .name="dejavu sans",
+    .always_use_100={on, 10, 14, 16, 17, end},
+    .m={on, 12, 0, end},
+    .stem_scaling={on, 12, 1, end},
+    .stem_translating_only={on, 8, 16, 15, -20, end}
+},
+{   .name="droid sans mono",
+    .m={on, 12, 0, end}
+},
+{   .name="droid sans",
+    .always_use_100={on, 12, 12, 15, 15, end},
+    .stem_translating_only={on, 8, 16, 9, 16, end}
+},
+{   .name="essential pragmatapro",
+    .always_use_100={on, 0, maxp, end},
+    .m={on, 13, 0, 14, 0, end}
+},
+{   .name="freemono",
+    .always_use_100={on, 0, maxp, end}
+},
+{   .name="freesans",
+    .always_use_100={on, 0, maxp, end},
+    .edge_detection={on, 11, 11, 13, 13, end},
+    .spacing={on, 10, 12, 18, 18, 30, end},
+    .start={on, 10, 18, 18, 25, 30, end},
+    .stem_scaling={on, 16, 0, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 16, 9, 8, end}
+},
+{   .name="freeserif",
+    .stem_scaling={on, 13, 1, 17, 1, end}
+},
+{   .name="futura",
+    .stem_widths={on, 10, 14, sw2pv, maxp,}
+},
+{   .name="garamond",
+    .brightness={on, 0, -20, end},
+    .contrast={on, 0, 25, end}
+},
+{   .name="georgia",
+    .stem_translating_only={on, 13, 16, 14, 16, 15, 0, end}
+},
+{   .name="gill sans",
+    .stem_widths={on, 10, 17, sw2pv, maxp,}
+},
+{   .name="helvetica cy",
+    .stem_widths={on, 10, 23, maxp,}
+},
+{   .name="inconsolata",
+    .stem_scaling={on, 12, 1, 15, 1, end},
+    .stem_translating_only={on, 10, 24, 9, 32, end},
+    .stem_widths={on, 10, 23, maxp,},
+},
+{   .name="liberation mono",
+    .always_use_100={on, 0, maxp, end}
+},
+{   .name="liberation sans narrow",
+    .stem_widths={on,10, 22, maxp,}
+},
+{   .name="liberation sans",
+    .edge_detection={on, 11, 11, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 10, 8, 8, 32, 9, 32, end},
+    .stem_widths={on,10, 19, maxp,}
+},
+{   .name="lucida console",
+    .always_use_100={on, 0, maxp, end}
+},
+{   .name="lucida grande",
+    .stem_scaling={on, 13, 1, end},
+    .stem_translating_only={on, 13, 24, 14, 24, 8, 16, 9, 16, end},
+    .stem_widths={on, 10, 16, sw2pv, maxp},
+},
+{   .name="lucida sans unicode",
+    .stem_translating_only={on, 13, 24, 14, 24, 8, 16, 9, 16, end},
+    .stem_widths={on,10, 16, sw2pv, maxp,}
+},
+{   .name="luxi sans",
+    .always_use_100={on, 13, 13, end},
+    .stem_widths={on, 10, 17, sw2pv, maxp,}
+},
+{   .name="microsoft sans serif",
+    .always_use_100={on, 0, maxp, end},
+    .stem_translating_only={on, 10, 16, 8, 32, 9, 32, end}
+},
+{   .name="monaco",
+    .always_use_100={on, 0, maxp, end}
+},
+{   .name="myriad pro",
+    .stem_scaling={on, 14, 1, 17, 1, end},
+    .stem_translating_only={on, 10, 16, 11, 0, 9, 16, end}
+},
+{   .name="nina",
+    .stem_scaling={on, 11, 0, 12, 0, 13, 0, end}
+},
+{   .name="open sans",
+    .stem_translating_only={on, 10, 16, 9, 16, end},
+    .stem_widths={on, 10, 20, maxp,}
+},
+{   .name="optima",
+    .brightness={on, 0, -20, end},
+    .contrast={on, 0, 25, end},
+    .stem_scaling={on, 17, 1, end},
+    .stem_translating_only={on, 10, 0, 11, 0, 12, 0, end}
+},
+{   .name="palatino linotype",
+    .edge_detection={on, 0, 100, end}
+},
+{   .name="pragmata",
+    .always_use_100={on, 0, maxp, end}
+},
+{   .name="raleway",
+    .stem_scaling={on, 15, 0, end}
+},
+{   .name="rokkitt",
+    .stem_widths={on, 10, 21, maxp,}
+},
+{   .name="samba",
+    .stem_scaling={on, 11, 0, end}
+},
+{   .name="segoe ui",
+    .always_use_100={on, 11, 12, 14, 14, end},
+    .stem_translating_only={on, 10, 0, 7, 32, 8, 16, 9, 24, end},
+    .stem_widths={on, 10, 23, maxp,}
+},
+{   .name="tahoma",
+    .always_use_100={on, 11, 11, 14, maxp, end},
+    .edge_detection={on, 11, 11, end},
+    .spacing={on, 10, 12, 18, 18, 30, end},
+    .start={on, 14, 17, 30, 100, 100, end},
+    .stem_translating={on, 11, 32, end},
+    .stem_translating_only={on, 7, 32, 8, 32, 9, 32, end},
+},
+{   .name="times new roman",
+    .always_use_100={on, 14, 14, 16, 16, end},
+    .bearing_correction={0, 100, end},
+    .stem_scaling={on, 17, 1, end},
+    .stem_translating_only={on, 17, 8, end}
+},
+{   .name="trebuchet ms",
+    .always_use_100={on, 13, 13, end},
+    .stem_scaling={on, 13, 0, 17, 0, 20, 1, end},
+    .stem_translating_only={on, 10, 16, 11, 0, 8, 32, 9, 32, end},
+    .stem_widths={on, 10, 17, sw2pv, maxp,}
+},
+{   .name="ubuntu",
+    .always_use_100={on, 12, 13, 15, 15, end}
+},
+{   .name="verdana",
+    .always_use_100={on, 0, 14, 16, maxp, end},
+    .stem_scaling={on, 12, 1, 15, 1, end},
+    .stem_translating_only={on, 8, 16, 15, 16, 14, 32, 18, 32, 19, 24, end}
+},
+%%
+
+static const sa_rules_t*
+ftinf_rules( const char *name ){
+    if( name ){
+        enum {
+            max_wlen=31
+        };
+        char buf[max_wlen+1];
+        int len=strlen( name );
+        if( len <= max_wlen ){
+            int i;
+            for( i=0; i<len; ++i )
+                buf[i]=tolower( name[i] );
+            buf[len]='\0';
+            return _rules_get( buf, len );
+        }
+    }
+    return NULL;
+}
+/*
+   gperf --output-file=ftinf_rh.c ftinf_rh.gperf
+*/
diff -Nur freetype-2.8/src/base/ftinf_sh.c freetype-2.8.compiles-with-mactype/src/base/ftinf_sh.c
--- freetype-2.8/src/base/ftinf_sh.c	1969-12-31 18:00:00.000000000 -0600
+++ freetype-2.8.compiles-with-mactype/src/base/ftinf_sh.c	2017-10-09 19:43:58.974807700 -0500
@@ -0,0 +1,463 @@
+/* ANSI-C code produced by gperf version 3.1 */
+/* Command-line: gperf --output-file=ftinf_sh.c ftinf_sh.gperf  */
+/* Computed positions: -k'1,$' */
+
+#if !((' ' == 32) && ('!' == 33) && ('"' == 34) && ('#' == 35) \
+      && ('%' == 37) && ('&' == 38) && ('\'' == 39) && ('(' == 40) \
+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \
+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \
+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \
+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \
+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \
+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \
+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \
+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \
+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \
+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \
+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \
+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \
+      && ('Z' == 90) && ('[' == 91) && ('\\' == 92) && (']' == 93) \
+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \
+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \
+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \
+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \
+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \
+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \
+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \
+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))
+/* The character set is not based on ISO-646.  */
+#error "gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>."
+#endif
+
+#line 9 "ftinf_sh.gperf"
+
+#include <ctype.h>
+static const struct ftinf_s* _settings_get( const char*str, unsigned len);
+/* maximum key range = 37, duplicates = 0 */
+
+#ifdef __GNUC__
+__inline
+#else
+#ifdef __cplusplus
+inline
+#endif
+#endif
+static unsigned int
+_settings_hash (register const char *str, register unsigned int len)
+{
+  static const unsigned char asso_values[] =
+    {
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 13,
+       8, 30, 25, 20, 40, 10, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40,  5, 40,  0,
+       0,  0, 40, 40, 10,  0, 40, 40, 15,  5,
+      10,  0, 10, 40, 40,  0,  0,  0,  0,  0,
+       0,  0, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40, 40, 40, 40, 40,
+      40, 40, 40, 40, 40, 40
+    };
+  return len + asso_values[(unsigned char)str[len - 1]] + asso_values[(unsigned char)str[0]];
+}
+
+#ifdef __GNUC__
+__inline
+#if defined __GNUC_STDC_INLINE__ || defined __GNUC_GNU_INLINE__
+__attribute__ ((__gnu_inline__))
+#endif
+#endif
+const struct ftinf_s *
+_settings_get (register const char *str, register unsigned int len)
+{
+  enum
+    {
+      TOTAL_KEYWORDS = 22,
+      MIN_WORD_LENGTH = 3,
+      MAX_WORD_LENGTH = 14,
+      MIN_HASH_VALUE = 3,
+      MAX_HASH_VALUE = 39
+    };
+
+  static const struct ftinf_s wordlist[] =
+    {
+#line 76 "ftinf_sh.gperf"
+{   .name="osx",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_vertical_stem_darken_strength=25,
+    .bold_embolden_x_value=16,
+    .brightness=10,
+    .contrast=20,
+    .filter_params={on, 3, 32, 38, 32, 3},
+    .gamma_correction={1000, 80},
+    .global_embolden_y_value=8,
+    .grayscale_filter_strength=25,
+},
+#line 37 "ftinf_sh.gperf"
+{   .name="ipad",
+    .filter_params={on, 0, 0, 100, 0, 0},
+    .gamma_correction={1000, 80},
+    .grayscale_filter_strength=100
+},
+#line 114 "ftinf_sh.gperf"
+{   .name="shove",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=100,
+    .stem_fitting_strength=100,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true
+},
+#line 126 "ftinf_sh.gperf"
+{   .name="ubuntu",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_vertical_stem_darken_strength=25,
+    .brightness=-10,
+    .contrast=15,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={1000, 80},
+    .use_various_tweaks=true
+},
+#line 27 "ftinf_sh.gperf"
+{   .name="classic",
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .filter_params={on, 6, 25, 38, 25, 6},
+    .gamma_correction={0, 100},
+    .use_various_tweaks=true
+},
+#line 34 "ftinf_sh.gperf"
+{   .name="disabled",
+    .gamma_correction={0, 100},
+},
+#line 100 "ftinf_sh.gperf"
+{   .name="sharpened",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=25,
+    .stem_fitting_strength=25,
+    .stem_snapping_sliding_scale=40,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=65
+},
+#line 42 "ftinf_sh.gperf"
+{   .name="infinality",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=25,
+    .stem_fitting_strength=25,
+    .stem_snapping_sliding_scale=40,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=5
+},
+#line 15 "ftinf_sh.gperf"
+{   .name="custom",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 8, 24, 48, 24, 8},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=75,
+    .stem_fitting_strength=50,
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true
+},
+#line 180 "ftinf_sh.gperf"
+{   .name="vanilla",
+    .filter_params={on, 6, 25, 38, 25, 6},
+    .gamma_correction={0, 100},
+},
+#line 184 "ftinf_sh.gperf"
+{   .name="windows7light",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .contrast=20,
+    .filter_params={on, 20, 25, 38, 25, 05},
+    .fringe_filter_strength=100,
+    .gamma_correction={1000, 160},
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=100
+},
+#line 226 "ftinf_sh.gperf"
+{   .name="windowsxplight",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .brightness=20,
+    .contrast=30,
+    .filter_params={on, 6, 25, 44, 25, 6},
+    .fringe_filter_strength=100,
+    .gamma_correction={1000, 120},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=65
+},
+#line 64 "ftinf_sh.gperf"
+{   .name="nudge",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=25,
+    .stem_fitting_strength=15,
+    .stem_snapping_sliding_scale=30,
+    .use_various_tweaks=true,
+},
+#line 144 "ftinf_sh.gperf"
+{   .name="ultimate2",
+    .filter_params={on, 6, 22, 36, 22, 6},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+},
+#line 197 "ftinf_sh.gperf"
+{   .name="windows7",
+    .filter_params={on, 20, 25, 42, 25, 06},
+    .fringe_filter_strength=100,
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_vertical_stem_darken_strength=25,
+    .windows_style_sharpening_strength=65,
+    .gamma_correction={1000, 120},
+    .brightness=10,
+    .contrast=20,
+    .use_various_tweaks=true,
+    .autohint_snap_stem_height=100,
+    .use_known_settings_on_selected_fonts=true,
+},
+#line 210 "ftinf_sh.gperf"
+{   .name="windowsxp",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .brightness=10,
+    .contrast=20,
+    .filter_params={on, 6, 25, 44, 25, 6},
+    .fringe_filter_strength=100,
+    .gamma_correction={1000, 120},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=65
+},
+#line 56 "ftinf_sh.gperf"
+{   .name="linux",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 6, 25, 44, 25, 6},
+    .gamma_correction={0, 100},
+    .use_various_tweaks=true
+},
+#line 135 "ftinf_sh.gperf"
+{   .name="ultimate1",
+    .filter_params={on, 4, 22, 38, 22, 4},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+},
+#line 87 "ftinf_sh.gperf"
+{   .name="push",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=75,
+    .stem_fitting_strength=50,
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true
+},
+#line 171 "ftinf_sh.gperf"
+{   .name="ultimate5",
+    .filter_params={on, 12, 28, 42, 28, 12},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+},
+#line 162 "ftinf_sh.gperf"
+{   .name="ultimate4",
+    .filter_params={on, 10, 25, 37, 25, 10},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+},
+#line 153 "ftinf_sh.gperf"
+{   .name="ultimate3",
+    .filter_params={on, 8, 24, 36, 24, 8},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+}
+    };
+
+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)
+    {
+      register int key = _settings_hash (str, len);
+
+      if (key <= MAX_HASH_VALUE && key >= MIN_HASH_VALUE)
+        {
+          register const struct ftinf_s *resword;
+
+          switch (key - 3)
+            {
+              case 0:
+                resword = &wordlist[0];
+                goto compare;
+              case 1:
+                resword = &wordlist[1];
+                goto compare;
+              case 2:
+                resword = &wordlist[2];
+                goto compare;
+              case 3:
+                resword = &wordlist[3];
+                goto compare;
+              case 4:
+                resword = &wordlist[4];
+                goto compare;
+              case 5:
+                resword = &wordlist[5];
+                goto compare;
+              case 6:
+                resword = &wordlist[6];
+                goto compare;
+              case 7:
+                resword = &wordlist[7];
+                goto compare;
+              case 8:
+                resword = &wordlist[8];
+                goto compare;
+              case 9:
+                resword = &wordlist[9];
+                goto compare;
+              case 10:
+                resword = &wordlist[10];
+                goto compare;
+              case 11:
+                resword = &wordlist[11];
+                goto compare;
+              case 12:
+                resword = &wordlist[12];
+                goto compare;
+              case 14:
+                resword = &wordlist[13];
+                goto compare;
+              case 15:
+                resword = &wordlist[14];
+                goto compare;
+              case 16:
+                resword = &wordlist[15];
+                goto compare;
+              case 17:
+                resword = &wordlist[16];
+                goto compare;
+              case 19:
+                resword = &wordlist[17];
+                goto compare;
+              case 21:
+                resword = &wordlist[18];
+                goto compare;
+              case 26:
+                resword = &wordlist[19];
+                goto compare;
+              case 31:
+                resword = &wordlist[20];
+                goto compare;
+              case 36:
+                resword = &wordlist[21];
+                goto compare;
+            }
+          return 0;
+        compare:
+          {
+            register const char *s = resword->name;
+
+            if (*str == *s && !strcmp (str + 1, s + 1))
+              return resword;
+          }
+        }
+    }
+  return 0;
+}
+#line 242 "ftinf_sh.gperf"
+
+
+static const ftinf_t*
+ftinf_settings( const char *name ){
+    if( name ){
+        enum {
+            max_wlen=31
+        };
+        char buf[max_wlen+1];
+        int len=strlen( name );
+        if( len <= max_wlen ){
+            int i;
+            for( i=0; i<len; ++i )
+                buf[i]=tolower( name[i] );
+            buf[len]='\0';
+            return _settings_get( buf, len );
+        }
+    }
+    return NULL;
+}
+/*
+   gperf --output-file=ftinf_sh.c ftinf_sh.gperf
+*/
diff -Nur freetype-2.8/src/base/ftinf_sh.gperf freetype-2.8.compiles-with-mactype/src/base/ftinf_sh.gperf
--- freetype-2.8/src/base/ftinf_sh.gperf	1969-12-31 18:00:00.000000000 -0600
+++ freetype-2.8.compiles-with-mactype/src/base/ftinf_sh.gperf	2017-10-09 19:43:58.977811900 -0500
@@ -0,0 +1,264 @@
+%struct-type
+%define slot-name name
+%enum
+%switch=1
+%readonly-tables
+%omit-struct-type
+%define lookup-function-name   _settings_get
+%define hash-function-name _settings_hash
+%{
+#include <ctype.h>
+static const struct ftinf_s* _settings_get( const char*str, unsigned len);
+%}
+struct ftinf_s;
+%%
+{   .name="custom",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 8, 24, 48, 24, 8},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=75,
+    .stem_fitting_strength=50,
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true
+},
+{   .name="classic",
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .filter_params={on, 6, 25, 38, 25, 6},
+    .gamma_correction={0, 100},
+    .use_various_tweaks=true
+},
+{   .name="disabled",
+    .gamma_correction={0, 100},
+},
+{   .name="ipad",
+    .filter_params={on, 0, 0, 100, 0, 0},
+    .gamma_correction={1000, 80},
+    .grayscale_filter_strength=100
+},
+{   .name="infinality",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=25,
+    .stem_fitting_strength=25,
+    .stem_snapping_sliding_scale=40,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=5
+},
+{   .name="linux",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 6, 25, 44, 25, 6},
+    .gamma_correction={0, 100},
+    .use_various_tweaks=true
+},
+{   .name="nudge",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=25,
+    .stem_fitting_strength=15,
+    .stem_snapping_sliding_scale=30,
+    .use_various_tweaks=true,
+},
+{   .name="osx",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_vertical_stem_darken_strength=25,
+    .bold_embolden_x_value=16,
+    .brightness=10,
+    .contrast=20,
+    .filter_params={on, 3, 32, 38, 32, 3},
+    .gamma_correction={1000, 80},
+    .global_embolden_y_value=8,
+    .grayscale_filter_strength=25,
+},
+{   .name="push",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=75,
+    .stem_fitting_strength=50,
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true
+},
+{   .name="sharpened",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=25,
+    .stem_fitting_strength=25,
+    .stem_snapping_sliding_scale=40,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=65
+},
+{   .name="shove",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_increase_glyph_heights=true,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=100,
+    .stem_fitting_strength=100,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true
+},
+{   .name="ubuntu",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_vertical_stem_darken_strength=25,
+    .brightness=-10,
+    .contrast=15,
+    .filter_params={on, 11, 22, 38, 22, 11},
+    .gamma_correction={1000, 80},
+    .use_various_tweaks=true
+},
+{   .name="ultimate1",
+    .filter_params={on, 4, 22, 38, 22, 4},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+},
+{   .name="ultimate2",
+    .filter_params={on, 6, 22, 36, 22, 6},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+},
+{   .name="ultimate3",
+    .filter_params={on, 8, 24, 36, 24, 8},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+},
+{   .name="ultimate4",
+    .filter_params={on, 10, 25, 37, 25, 10},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+},
+{   .name="ultimate5",
+    .filter_params={on, 12, 28, 42, 28, 12},
+    .fringe_filter_strength=25,
+    .gamma_correction={0, 100},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=25
+},
+{   .name="vanilla",
+    .filter_params={on, 6, 25, 38, 25, 6},
+    .gamma_correction={0, 100},
+},
+{   .name="windows7light",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .contrast=20,
+    .filter_params={on, 20, 25, 38, 25, 05},
+    .fringe_filter_strength=100,
+    .gamma_correction={1000, 160},
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=100
+},
+{   .name="windows7",
+    .filter_params={on, 20, 25, 42, 25, 06},
+    .fringe_filter_strength=100,
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_vertical_stem_darken_strength=25,
+    .windows_style_sharpening_strength=65,
+    .gamma_correction={1000, 120},
+    .brightness=10,
+    .contrast=20,
+    .use_various_tweaks=true,
+    .autohint_snap_stem_height=100,
+    .use_known_settings_on_selected_fonts=true,
+},
+{   .name="windowsxp",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .brightness=10,
+    .contrast=20,
+    .filter_params={on, 6, 25, 44, 25, 6},
+    .fringe_filter_strength=100,
+    .gamma_correction={1000, 120},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=65
+},
+{   .name="windowsxplight",
+    .autohint_horizontal_stem_darken_strength=10,
+    .autohint_snap_stem_height=100,
+    .autohint_vertical_stem_darken_strength=25,
+    .brightness=20,
+    .contrast=30,
+    .filter_params={on, 6, 25, 44, 25, 6},
+    .fringe_filter_strength=100,
+    .gamma_correction={1000, 120},
+    .stem_alignment_strength=15,
+    .stem_fitting_strength=15,
+    .stem_snapping_sliding_scale=30,
+    .use_known_settings_on_selected_fonts=true,
+    .use_various_tweaks=true,
+    .windows_style_sharpening_strength=65
+},
+%%
+
+static const ftinf_t*
+ftinf_settings( const char *name ){
+    if( name ){
+        enum {
+            max_wlen=31
+        };
+        char buf[max_wlen+1];
+        int len=strlen( name );
+        if( len <= max_wlen ){
+            int i;
+            for( i=0; i<len; ++i )
+                buf[i]=tolower( name[i] );
+            buf[len]='\0';
+            return _settings_get( buf, len );
+        }
+    }
+    return NULL;
+}
+/*
+   gperf --output-file=ftinf_sh.c ftinf_sh.gperf
+*/
diff -Nur freetype-2.8/src/base/ftinit.c freetype-2.8.compiles-with-mactype/src/base/ftinit.c
--- freetype-2.8/src/base/ftinit.c	2017-03-30 05:20:23.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/src/base/ftinit.c	2017-10-10 19:23:46.788328800 -0500
@@ -38,12 +38,16 @@
 
 
 #include <ft2build.h>
+#include <stdio.h>
+#include <stdlib.h>
 #include FT_CONFIG_CONFIG_H
 #include FT_INTERNAL_OBJECTS_H
 #include FT_INTERNAL_DEBUG_H
 #include FT_MODULE_H
 #include "basepic.h"
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include "ftinf.h"
+#endif
 
   /*************************************************************************/
   /*                                                                       */
@@ -246,7 +250,7 @@
     int  i;
 
 
-    env = ft_getenv( "FREETYPE_PROPERTIES" );
+    env = getenv( "FREETYPE_PROPERTIES" );
     if ( !env )
       return;
 
@@ -341,10 +345,14 @@
     error = FT_New_Library( memory, alibrary );
     if ( error )
       FT_Done_Memory( memory );
-    else
+    else {
       FT_Add_Default_Modules( *alibrary );
-
-    FT_Set_Default_Properties( *alibrary );
+      FT_Set_Default_Properties( *alibrary );
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+      /* get Infinality settings */
+      ftinf_env();
+#endif
+    }
 
     return error;
   }
diff -Nur freetype-2.8/src/base/ftlcdfil.c freetype-2.8.compiles-with-mactype/src/base/ftlcdfil.c
--- freetype-2.8/src/base/ftlcdfil.c	2017-03-30 05:20:23.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/src/base/ftlcdfil.c	2017-10-09 19:48:35.159558000 -0500
@@ -22,7 +22,10 @@
 #include FT_LCD_FILTER_H
 #include FT_IMAGE_H
 #include FT_INTERNAL_OBJECTS_H
+#include <math.h>
+#include <string.h>
 
+#include "ftinf.h"
 
 #ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
 
@@ -306,11 +309,37 @@
   FT_Library_SetLcdFilter( FT_Library    library,
                            FT_LcdFilter  filter )
   {
-    static const FT_LcdFiveTapFilter  default_weights =
-                   { 0x08, 0x4d, 0x56, 0x4d, 0x08 };
     static const FT_LcdFiveTapFilter  light_weights =
                    { 0x00, 0x55, 0x56, 0x55, 0x00 };
 
+#ifndef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    static const FT_LcdFiveTapFilter  default_weights =
+                   { 0x08, 0x4d, 0x56, 0x4d, 0x08 };
+#else
+    FT_LcdFiveTapFilter default_weights;
+    if( ftinf && ftinf->filter_params[0] )
+    {
+        const int *f=ftinf->filter_params;
+        /* Assume we were given integers [0-100] get them to [0-255] */
+        int val; /* 2611=2.55*1024 */
+        val=(f[1]*2611+512)>>10; if( val > 255 ) val=255;
+        default_weights[0] = (FT_Byte) val;
+        val=(f[2]*2611+512)>>10; if( val > 255 ) val=255;
+        default_weights[1] = (FT_Byte) val;
+        val=(f[3]*2611+512)>>10; if( val > 255 ) val=255;
+        default_weights[2] = (FT_Byte) val;
+        val=(f[4]*2611+512)>>10; if( val > 255 ) val=255;
+        default_weights[3] = (FT_Byte) val;
+        val=(f[5]*2611+512)>>10; if( val > 255 ) val=255;
+        default_weights[4] = (FT_Byte) val;
+    } else {
+        default_weights[0]=0x08;
+        default_weights[1]=0x4d;
+        default_weights[2]=0x56;
+        default_weights[3]=0x4d;
+        default_weights[4]=0x08;
+    }
+#endif
 
     if ( !library )
       return FT_THROW( Invalid_Library_Handle );
diff -Nur freetype-2.8/src/base/ftobjs.c freetype-2.8.compiles-with-mactype/src/base/ftobjs.c
--- freetype-2.8/src/base/ftobjs.c	2017-05-01 02:33:38.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/src/base/ftobjs.c	2017-10-09 19:48:24.519898100 -0500
@@ -43,7 +43,9 @@
 #ifdef FT_CONFIG_OPTION_MAC_FONTS
 #include "ftbase.h"
 #endif
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include "ftinf.h"
+#endif
 
 #ifdef FT_DEBUG_LEVEL_TRACE
 
@@ -81,6 +83,11 @@
 
 #define GRID_FIT_METRICS
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include <string.h>
+#include <stdlib.h>
+#include "../autofit/aflatin.h"
+#endif
 
   /* forward declaration */
   static FT_Error
@@ -567,6 +574,25 @@
   ft_lookup_glyph_renderer( FT_GlyphSlot  slot );
 
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+  static void
+  ft_glyphslot_enlarge_metrics( FT_GlyphSlot slot,
+                                FT_Render_Mode mode )
+  {
+    FT_Glyph_Metrics*  metrics = &slot->metrics;
+    FT_Pos enlarge_cbox = 0;
+
+
+    /* enlarge for grayscale rendering */
+    if ( mode == FT_RENDER_MODE_NORMAL )
+      enlarge_cbox = 64;
+
+    metrics->horiBearingX -= enlarge_cbox;
+    metrics->width += 2 * enlarge_cbox;
+  }
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
+
+
 #ifdef GRID_FIT_METRICS
   static void
   ft_glyphslot_grid_fit_metrics( FT_GlyphSlot  slot,
@@ -625,8 +651,18 @@
     FT_Bool       autohint = FALSE;
     FT_Module     hinter;
     TT_Face       ttface = (TT_Face)face;
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
 
+    FT_Bool use_various_tweaks = FALSE;
+    if( ftinf ) use_various_tweaks=ftinf->use_various_tweaks;
 
+    /* Force autohint if no tt instructions */
+    /* NOTE:  NEEDS TO BE RUN LATER IN CODE???? */
+    /*if ( use_various_tweaks                             &&
+         ttface->num_locations                          &&
+         ttface->max_profile.maxSizeOfInstructions == 0 )
+      load_flags |= FT_LOAD_FORCE_AUTOHINT;*/
+#endif
     if ( !face || !face->size || !face->glyph )
       return FT_THROW( Invalid_Face_Handle );
 
@@ -717,6 +753,18 @@
     {
       FT_AutoHinter_Interface  hinting;
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+      if ( use_various_tweaks )
+      {
+        /* Force slight hinting over full hinting always */
+        load_flags &= ~FT_LOAD_TARGET_LCD;
+        load_flags &= ~FT_LOAD_TARGET_LCD_V;
+        load_flags &= ~FT_LOAD_TARGET_MONO;
+        load_flags &= ~FT_LOAD_TARGET_NORMAL;
+        load_flags |= FT_LOAD_TARGET_LIGHT;
+        /*printf("%d ", load_flags);*/
+      }
+#endif
 
       /* try to load embedded bitmaps first if available            */
       /*                                                            */
@@ -762,6 +810,18 @@
       if ( error )
         goto Exit;
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+      infinality_cur_width = 0;
+
+      {
+        /* fix for sdl_ttf */
+        FT_Render_Mode  mode = FT_LOAD_TARGET_MODE( load_flags );
+
+        if ( slot->format == FT_GLYPH_FORMAT_OUTLINE )
+          ft_glyphslot_enlarge_metrics( slot, mode );
+      }
+#endif
+
       if ( slot->format == FT_GLYPH_FORMAT_OUTLINE )
       {
         /* check that the loaded outline is correct */
@@ -4986,6 +5046,11 @@
     /* That's ok now */
     *alibrary = library;
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    /* get Infinality settings */
+    ftinf_env();
+#endif
+
     return FT_Err_Ok;
 
 #ifdef FT_CONFIG_OPTION_PIC
diff -Nur freetype-2.8/src/base/ftoutln.c freetype-2.8.compiles-with-mactype/src/base/ftoutln.c
--- freetype-2.8/src/base/ftoutln.c	2017-03-30 05:20:23.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/src/base/ftoutln.c	2017-10-09 19:43:58.984817400 -0500
@@ -29,7 +29,9 @@
 #include FT_INTERNAL_CALC_H
 #include FT_INTERNAL_DEBUG_H
 #include FT_TRIGONOMETRY_H
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include "ftinf.h"
+#endif
 
   /*************************************************************************/
   /*                                                                       */
@@ -913,7 +915,13 @@
     FT_Vector*  points;
     FT_Int      c, first, last;
     FT_Int      orientation;
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    FT_Bool use_various_tweaks = FALSE;
+    if( ftinf ) use_various_tweaks=ftinf->use_various_tweaks;
+
+    if ( use_various_tweaks )
+      ystrength = FT_PIX_FLOOR ( ystrength );
+#endif
 
     if ( !outline )
       return FT_THROW( Invalid_Outline );
diff -Nur freetype-2.8/src/base/ftsynth.c freetype-2.8.compiles-with-mactype/src/base/ftsynth.c
--- freetype-2.8/src/base/ftsynth.c	2017-03-30 05:20:23.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/src/base/ftsynth.c	2017-10-09 19:43:58.986819300 -0500
@@ -22,7 +22,9 @@
 #include FT_INTERNAL_OBJECTS_H
 #include FT_OUTLINE_H
 #include FT_BITMAP_H
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include "ftinf.h"
+#endif
 
   /*************************************************************************/
   /*                                                                       */
@@ -93,7 +95,10 @@
     FT_Face     face;
     FT_Error    error;
     FT_Pos      xstr, ystr;
-
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    FT_Bool use_various_tweaks = FALSE;
+    if( ftinf ) use_various_tweaks=ftinf->use_various_tweaks;
+#endif
 
     if ( !slot )
       return;
@@ -111,8 +116,16 @@
     ystr = xstr;
 
     if ( slot->format == FT_GLYPH_FORMAT_OUTLINE )
+    {
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+      if ( use_various_tweaks )
+        (void)FT_Outline_EmboldenXY( &slot->outline,
+                                     xstr,
+                                     FT_PIX_FLOOR( ystr ) );
+      else
+#endif
       FT_Outline_EmboldenXY( &slot->outline, xstr, ystr );
-
+    }
     else /* slot->format == FT_GLYPH_FORMAT_BITMAP */
     {
       /* round to full pixels */
@@ -150,6 +163,9 @@
 
     slot->metrics.width        += xstr;
     slot->metrics.height       += ystr;
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    if ( !use_various_tweaks )
+#endif
     slot->metrics.horiAdvance  += xstr;
     slot->metrics.vertAdvance  += ystr;
     slot->metrics.horiBearingY += ystr;
diff -Nur freetype-2.8/src/base/Jamfile freetype-2.8.compiles-with-mactype/src/base/Jamfile
--- freetype-2.8/src/base/Jamfile	2017-03-30 05:20:23.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/src/base/Jamfile	2017-10-09 19:43:58.960795900 -0500
@@ -56,6 +56,7 @@
                     ftglyph
                     ftgxval
                     ftinit
+                    ftinf
                     ftlcdfil
                     ftmm
                     ftotval
diff -Nur freetype-2.8/src/base/rules.mk freetype-2.8.compiles-with-mactype/src/base/rules.mk
--- freetype-2.8/src/base/rules.mk	2017-03-30 05:20:23.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/src/base/rules.mk	2017-10-09 19:43:58.987820100 -0500
@@ -42,6 +42,7 @@
             $(BASE_DIR)/ftdbgmem.c \
             $(BASE_DIR)/ftgloadr.c \
             $(BASE_DIR)/fthash.c   \
+            $(BASE_DIR)/ftinf.c    \
             $(BASE_DIR)/ftobjs.c   \
             $(BASE_DIR)/ftoutln.c  \
             $(BASE_DIR)/ftpic.c    \
diff -Nur freetype-2.8/src/cff/cffobjs.c freetype-2.8.compiles-with-mactype/src/cff/cffobjs.c
--- freetype-2.8/src/cff/cffobjs.c	2017-04-22 05:37:22.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/src/cff/cffobjs.c	2017-10-09 19:43:58.989321800 -0500
@@ -39,6 +39,9 @@
 
 #include "cfferrs.h"
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include "../base/ftinf.h"
+#endif
 
   /*************************************************************************/
   /*                                                                       */
@@ -1172,6 +1175,9 @@
 #endif
 
     driver->no_stem_darkening = TRUE;
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    if(ftinf) driver->no_stem_darkening = !ftinf->stem_darkening_cff;
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
 
     driver->darken_params[0] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_X1;
     driver->darken_params[1] = CFF_CONFIG_OPTION_DARKENING_PARAMETER_Y1;
diff -Nur freetype-2.8/src/smooth/ftsmooth.c freetype-2.8.compiles-with-mactype/src/smooth/ftsmooth.c
--- freetype-2.8/src/smooth/ftsmooth.c	2017-05-01 02:35:12.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/src/smooth/ftsmooth.c	2017-10-10 19:03:03.513827800 -0500
@@ -26,6 +26,18 @@
 
 #include "ftsmerrs.h"
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+#include <math.h>
+#include FT_BITMAP_H
+#include <string.h>
+
+#include FT_OUTLINE_H
+#include "../base/ftinf.h"
+
+#define verbose FALSE
+#define STVALUES if (verbose) \
+  printf ( "scale:%f translate:%ld ", *scale_value, *translate_value );
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
 
   /* initialize renderer -- init its raster */
   static FT_Error
@@ -93,6 +105,2219 @@
       FT_Outline_Get_CBox( &slot->outline, cbox );
   }
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+  static FT_Fixed FT_FixedFromFloat(float f)
+  {
+    short          value = f;
+    unsigned short fract = (f - value) * 0xFFFF;
+
+
+    return (FT_Fixed)((long)value << 16 | (unsigned long)fract );
+  }
+
+
+  /* ChromeOS sharpening algorithm */
+  /* soften the sub-pixel anti-aliasing and sharpen */
+  static void
+  _ft_lcd_chromeos_sharpen( FT_Bitmap*  bitmap,
+                        FT_Render_Mode  mode,
+                        FT_Byte         cutoff,
+                        double          gamma_value )
+  {
+    static FT_Bool        initialized_gamma = FALSE;
+    static unsigned short gamma_ramp[256];
+    FT_UInt               width  = (FT_UInt)bitmap->width;
+    FT_UInt               height = (FT_UInt)bitmap->rows;
+    int    ii;
+
+    if ( !initialized_gamma )
+    {
+      initialized_gamma = TRUE;
+      /* linear to voltage */
+      for ( ii = 0; ii < 256; ii++ )
+      {
+        gamma_ramp[ii] = (unsigned char)
+                         ( pow( (double)ii / 255.0, gamma_value ) * 255.0f );
+        if ( gamma_ramp[ii] < cutoff )
+          gamma_ramp[ii] = 0;
+      }
+    }
+
+    /* horizontal in-place sub-pixel sharpening filter */
+    if ( mode == FT_RENDER_MODE_LCD )
+    {
+      FT_Byte*  line = bitmap->buffer;
+
+
+      for ( ; height > 0; height--, line += bitmap->pitch )
+      {
+        FT_UInt  xx;
+
+
+        for ( xx = 0; xx < width; xx++ )
+          line[xx] = gamma_ramp[line[xx]];
+      }
+    }
+  }
+
+  /* simple linear scale to handle various sliding values */
+  float
+  sliding_scale ( int            min_value,
+                      int        max_value,
+                      float      min_amount,
+                      float      max_amount,
+                      int        cur_value )
+  {
+
+    float m = ( min_amount - max_amount ) / (float)( min_value - max_value );
+    float result = ( ( (float)cur_value * m) + ( max_amount - max_value * m ) ) ;
+
+    if ( min_amount < max_amount )
+    {
+      if ( result < min_amount )
+        return min_amount;
+      if ( result > max_amount )
+        return max_amount;
+    }
+    else
+    {
+      if ( result < max_amount )
+        return max_amount;
+      if ( result > min_amount )
+        return min_amount;
+    }
+
+    return result;
+  }
+
+
+  /* brightness and contrast adjustment on the bitmap */
+  static FT_Bool
+  _ft_bitmap_bc  ( FT_Bitmap*       bitmap,
+                      float         brightness,
+                      float         contrast )
+  {
+
+    FT_UInt   width   = (FT_UInt)bitmap->width;
+    FT_UInt   height  = (FT_UInt)bitmap->rows;
+    FT_Byte*  line    = bitmap->buffer;
+    FT_UInt   xx;
+
+
+    if ( brightness == 0 && contrast == 0 )
+      return FALSE;
+
+    for ( height = (FT_UInt)bitmap->rows;
+          height > 0;
+          height--, line += bitmap->pitch )
+    {
+      for ( xx = 0; xx < width - 1; xx += 1 )
+      {
+        if ( line[xx] > 0)
+        {
+          float  value  = (float)( 255 - line[xx] ) / 256.0;
+          FT_Int result = 0;
+
+          if ( brightness < 0.0 )
+            value = value * ( 1.0 + brightness );
+          else
+            value = value + ( ( 1.0 - value ) * brightness );
+
+          value = ( value - 0.5 ) *
+                    ( tan ( ( contrast + 1.0 ) * 3.141592/4.0 ) ) + 0.5;
+
+          result = (FT_Int)( 255.0 - value * 256.0 );
+
+          if ( result < 0 )
+            result = 0;
+          if ( result > 255 )
+            result = 255;
+
+          line[xx] = result;
+        }
+      }
+    }
+    return TRUE;
+  }
+
+
+  /* Filter to mimic Windows-style sharpening */
+  /* Determined via 100% experimentation.     */
+  static void
+  _ft_lcd_windows_sharpen( FT_Bitmap*      bitmap,
+                           FT_Render_Mode  mode,
+                           FT_UInt         strength,
+                           FT_Library      library )
+  {
+
+    FT_UInt   width   = (FT_UInt)bitmap->width;
+    FT_UInt   height  = (FT_UInt)bitmap->rows;
+    FT_Byte*  new_line;
+    FT_Byte*  line = bitmap->buffer;
+    FT_Bitmap new_bitmap;
+
+
+    FT_Bitmap_Init( &new_bitmap );
+    FT_Bitmap_Copy( library, bitmap, &new_bitmap );
+    new_line = (&new_bitmap)->buffer;
+
+    if (strength > 0)
+      for (height = (FT_UInt)bitmap->rows;
+           height > 0;
+           height--, line += bitmap->pitch, new_line += bitmap->pitch )
+    {
+      FT_UInt   xx, threshold = 128;
+      FT_Byte*  prevline      = line - bitmap->pitch;
+      FT_Byte*  nextline      = line + bitmap->pitch;
+      FT_Byte*  new_prevline  = new_line - bitmap->pitch;
+      FT_Byte*  new_nextline  = new_line + bitmap->pitch;
+
+      for ( xx = 1; xx < width - 1; xx += 1 )
+      {
+        /* subpixel grid       sp11 sp21 sp31   */
+        /* where sp22 is       sp12 sp22 sp32   */
+        /* current subpixel.   sp13 sp23 sp33   */
+
+        FT_Int prevtotal, nexttotal, lefttotal, righttotal, sidesdiff,
+          prevdiff, nextdiff, sp11, sp21, sp31, sp12, sp22, sp32,
+          sp13, sp23, sp33;
+
+        sp12 = line [xx-1];
+        sp22 = line [xx];
+        sp32 = line [xx+1];
+
+        if ( height == bitmap->rows )
+        {
+          prevtotal = sp11 = sp21 = sp31 = 0;
+          prevdiff = sp22;
+          lefttotal = sp12 + sp13;
+          righttotal = sp32 + sp33;
+        }
+        else
+        {
+          prevtotal = prevline[xx-1] + prevline[xx] + prevline[xx+1];
+          sp11 = prevline [xx-1];
+          sp21 = prevline [xx];
+          sp31 = prevline [xx+1];
+          prevdiff = sp22 - sp21;
+          lefttotal = sp11 + sp12 + sp13;
+          righttotal = sp31 + sp32 + sp33;
+        }
+
+        if ( height == 1 )
+        {
+          nexttotal = sp13 = sp23 = sp33 = 0;
+          nextdiff = sp22;
+          lefttotal = sp11 + sp12;
+          righttotal = sp31 + sp32;
+        }
+        else
+        {
+          nexttotal = nextline[xx-1] + nextline[xx] + nextline[xx+1];
+          sp13 = nextline [xx-1];
+          sp23 = nextline [xx];
+          sp33 = nextline [xx+1];
+          nextdiff = sp23 - sp22;
+          lefttotal = sp11 + sp12 + sp13;
+          righttotal = sp31 + sp32 + sp33;
+        }
+
+        sidesdiff = lefttotal - righttotal;
+
+        if ( sidesdiff < 0 )
+          sidesdiff *= -1;
+
+        if ( prevdiff < 0 )
+          prevdiff *= -1;
+
+        if ( nextdiff < 0 )
+          nextdiff *= -1;
+
+        /* if the current pixel is less than threshold, and greater than 0  */
+        if ( sp22 <= threshold && sp22 > 0 )
+        {
+          /* A pixel is horizontally isolated if: */
+          /* 1: All upper adjecent pixels are >= threshold */
+          if ( prevtotal >= nexttotal  &&
+               abs( sp11 - sp12 ) > 5  &&
+               abs( sp21 - sp22 ) > 5  &&
+               abs( sp31 - sp32 ) > 5  && /* not a vert stem end */
+               sp11 >= threshold       &&
+               sp21 >= threshold       &&
+               sp31 >= threshold       &&
+               abs( sp23 - sp22 ) > 15 )  /* not on a vert stem */
+          {
+            /* darken upper adjacent subpixel;  lighten current */
+            if ( height != (FT_UInt)bitmap->rows )
+              new_prevline[xx] += ( ( 255 - new_prevline[xx] )
+                                      * strength ) / 100 ;
+
+            new_line[xx] -= ( new_line[xx] * strength ) / 100;
+
+            if ( height != 1 && height != (FT_UInt)bitmap->rows )
+              if ( new_nextline[xx] > 155 + ( 100 - strength ) )
+                new_prevline[xx] = 255;
+
+          }
+          else if ( nexttotal > prevtotal  &&
+                    abs( sp13 - sp12 ) > 5  &&
+                    abs( sp23 - sp22 ) > 5  &&
+                    abs( sp33 - sp32 ) > 5  &&
+                    /* 2: All lower adjecent pixels are >= threshold */
+                    sp13 >= threshold      &&
+                    sp23 >= threshold      &&
+                    sp33 >= threshold      &&
+                    abs( sp22 - sp21 ) > 15 )
+          {
+            /* darken lower adjacent subpixel;  lighten current */
+            if ( height != 1 )
+              new_nextline[xx] += ( 255 - new_nextline[xx] ) * strength / 100;
+
+            new_line[xx] -= ( new_line[xx] * strength ) / 100;
+
+            if ( height != 1 )
+              if ( new_nextline[xx] > 155 + ( 100 - strength ) )
+                new_nextline[xx] = 255;
+
+          }
+        }
+        else if ( sp22 > threshold && sp22 < 255 )
+        {
+          if ( sp11 <= threshold       &&
+               abs( sp13 - sp12 ) > 5  &&
+               abs( sp23 - sp22 ) > 5  &&
+               abs( sp33 - sp32 ) > 5  &&
+               sp21 <= threshold       &&
+               sp31 <= threshold       &&
+               prevtotal <= nexttotal  &&
+               abs( sp22 - sp21 ) > 15 )
+          {
+            /* bring this subpixel 1/3 of the way to 255 at 100% strength */
+            new_line[xx] += ( strength * ( 255 - new_line[xx] ) ) / 100;
+
+            if ( height != (FT_UInt)bitmap->rows )
+              new_prevline[xx] -= ( new_prevline[xx] * strength ) / 300;
+          }
+          else if ( sp13 <= threshold       &&
+                    abs( sp11 - sp12 ) > 5  &&
+                    abs( sp21 - sp22 ) > 5  &&
+                    abs( sp31 - sp32 ) > 5  &&
+                    sp23 <= threshold       &&
+                    sp33 <= threshold       &&
+                    nexttotal < prevtotal   &&
+                    abs( sp23 - sp22 ) > 15 )
+          {
+            new_line[xx] += ( strength * ( 255 - new_line[xx] ) ) / 100;
+
+            if ( height != 1 )
+              new_nextline[xx] -= ( new_nextline[xx] * strength ) / 300;
+          }
+        }
+      }
+    }
+    FT_Bitmap_Copy( library, &new_bitmap, bitmap);
+    FT_Bitmap_Done( library, &new_bitmap );
+  }
+
+
+  static void
+  _ft_lcd_darken_x  ( FT_Bitmap*      bitmap,
+                      FT_Render_Mode  mode,
+                      FT_UInt         strength,
+                      FT_Library      library )
+  {
+
+    FT_UInt   width   = (FT_UInt)bitmap->width;
+    FT_UInt   height  = (FT_UInt)bitmap->rows;
+    FT_Byte*  new_line;
+    FT_Byte*  line = bitmap->buffer;
+    FT_Bitmap new_bitmap;
+    int       factor1, factor2;
+    int       bias = 0;
+
+    FT_Bitmap_Init( &new_bitmap );
+
+    FT_Bitmap_Copy( library, bitmap, &new_bitmap );
+    new_line = (&new_bitmap)->buffer;
+
+    if ( strength > 0 )
+      for ( height = (FT_UInt)bitmap->rows;
+            height > 0;
+            height--, line += bitmap->pitch, new_line += bitmap->pitch )
+    {
+      FT_UInt   xx;
+      FT_Byte*  prevline = line - bitmap->pitch;
+      FT_Byte*  nextline = line + bitmap->pitch;
+
+      for ( xx = 1; xx < width - 1; xx += 1 )
+      {
+        /* subpixel grid       sp11 sp21 sp31   */
+        /* where sp22 is       sp12 sp22 sp32   */
+        /* current subpixel.   sp13 sp23 sp33   */
+
+        FT_Int sp21, sp12, sp22, sp32, sp23;
+
+        sp12 = line [xx-1];
+        sp22 = line [xx];
+        sp32 = line [xx+1];
+
+        if ( height == bitmap->rows )
+          sp21 = 0;
+        else
+          sp21 = prevline [xx];
+
+        if ( height == 1 )
+          sp23 = 0;
+        else
+          sp23 = nextline [xx];
+
+        /* darken subpixel if neighbor above and below are much less than */
+        /* safer but less effective */
+        factor1 = 5;
+        factor2 = 5;
+
+        /* make matches in the middle of glyph slightly darker */
+        /*if (height > 1 && height < (FT_UInt)bitmap->rows) bias = 1;*/
+
+        if ( sp22 > factor1 * sp21  &&
+             sp22  > factor1 * sp23 &&
+             sp22 > factor2         &&
+             sp12 > 16              &&
+             sp32 > 16              )
+          if ( new_line[xx] < ( strength * 255 ) / 100 )
+            new_line[xx] = (strength * 255 ) / 100
+                             + bias * ( 255 - ( strength * 255 ) / 100 ) / 3;
+
+      }
+    }
+    FT_Bitmap_Copy( library, &new_bitmap, bitmap );
+    FT_Bitmap_Done( library, &new_bitmap );
+  }
+
+
+  static void
+  _ft_lcd_darken_y  ( FT_Bitmap*      bitmap,
+                      FT_Render_Mode  mode,
+                      FT_UInt         strength,
+                      FT_Library      library )
+  {
+
+    FT_UInt   width   = (FT_UInt)bitmap->width;
+    FT_UInt   height  = (FT_UInt)bitmap->rows;
+    FT_Byte*  new_line;
+    FT_Byte*  line = bitmap->buffer;
+    FT_Bitmap   new_bitmap;
+
+
+    FT_Bitmap_Init( &new_bitmap );
+    FT_Bitmap_Copy( library, bitmap, &new_bitmap );
+    new_line = (&new_bitmap)->buffer;
+
+    if ( strength > 0 )
+      for ( height = (FT_UInt)bitmap->rows;
+            height > 0;
+            height--, line += bitmap->pitch, new_line += bitmap->pitch )
+    {
+      FT_UInt  xx;
+
+
+      for ( xx = 1; xx < width - 1; xx += 1 )
+      {
+        if ( line[xx] > line[xx-1] && line[xx] > line[xx+1] )
+        {
+           if (new_line[xx] > 0)
+             new_line[xx] += ( strength * ( 255 - new_line[xx] ) ) / 100;
+           new_line[xx-1] += ( strength * ( 255 - line[xx-1] ) ) / 100;
+           new_line[xx+1] += ( strength * ( 255 - line[xx+1] ) ) / 100;
+        }
+      }
+    }
+    FT_Bitmap_Copy( library, &new_bitmap, bitmap );
+    FT_Bitmap_Done( library, &new_bitmap );
+  }
+
+
+  static void
+  _ft_bitmap_cap  ( FT_Bitmap*      bitmap,
+                    FT_UInt         strength,
+                    FT_Library      library )
+  {
+
+    FT_UInt   width   = (FT_UInt)bitmap->width;
+    FT_UInt   height  = (FT_UInt)bitmap->rows;
+    FT_Byte*  new_line;
+    FT_Byte*  line = bitmap->buffer;
+    FT_UInt   cur_value = 0;
+    FT_Bitmap new_bitmap;
+
+
+    FT_Bitmap_Init( &new_bitmap );
+    FT_Bitmap_Copy( library, bitmap, &new_bitmap );
+    new_line = (&new_bitmap)->buffer;
+
+    if ( strength > 0 )
+      for ( height = (FT_UInt)bitmap->rows;
+            height > 0;
+            height--, line += bitmap->pitch, new_line += bitmap->pitch )
+    {
+      FT_UInt  xx;
+
+
+      for ( xx = 1; xx < width - 1; xx += 1 )
+      {
+        cur_value = ( new_line[xx-1] + new_line[xx] + new_line[xx+1] ) / 3;
+        if ( cur_value > ( strength * 255 ) / 100 )
+        {
+          FT_UInt new_factor = ( strength * 255 ) / 100;
+          new_line[xx] = ( new_line[xx] * new_factor ) / cur_value;
+          new_line[xx+1] = ( new_line[xx+1] * new_factor ) / cur_value;
+          new_line[xx-1] = ( new_line[xx-1] * new_factor ) / cur_value;
+        }
+      }
+    }
+    FT_Bitmap_Copy( library, &new_bitmap, bitmap );
+    FT_Bitmap_Done( library, &new_bitmap );
+  }
+
+  static int
+  pseudo_gamma ( int val, float value )
+  {
+      return 256 * ( 1.0f - powf( ( 1.0f - val * (1.0f/256.0f) ), 1.0f / value ) );
+  }
+
+#if(0)
+  static void
+  _ft_bitmap_embolden  ( FT_Bitmap*      bitmap,
+                         FT_UInt         strength,
+                         FT_Library      library )
+  {
+
+    FT_UInt   width   = (FT_UInt)bitmap->width;
+    FT_UInt   height  = (FT_UInt)bitmap->rows;
+    FT_Byte*  new_line;
+    FT_Byte*  line = bitmap->buffer;
+    FT_Bitmap new_bitmap;
+    FT_UInt   xx;
+
+
+    FT_Bitmap_Init(&new_bitmap);
+    FT_Bitmap_Copy(library, bitmap, &new_bitmap);
+    new_line = (&new_bitmap)->buffer;
+
+    if ( strength > 0 )
+      for ( height = (FT_UInt)bitmap->rows;
+            height > 0;
+            height--, line += bitmap->pitch, new_line += bitmap->pitch )
+    {
+      for ( xx = 1; xx < width - 1; xx += 1 )
+      {
+        FT_Int new_value = 0;
+
+
+        new_value = ( strength * line [xx-1] ) / 100
+                      + pseudo_gamma( line [xx], .75 )
+                      + (strength * line [xx+1] ) / 100;
+        if ( new_value > 255 )
+          new_value = 255;
+
+        new_line[xx] = new_value;
+      }
+    }
+    FT_Bitmap_Copy( library, &new_bitmap, bitmap );
+    FT_Bitmap_Done( library, &new_bitmap );
+  }
+
+
+
+  static void
+  _ft_bitmap_gamma  ( FT_Bitmap*    bitmap,
+                      float         strength )
+  {
+
+    FT_UInt   width   = (FT_UInt)bitmap->width;
+    FT_UInt   height  = (FT_UInt)bitmap->rows;
+    FT_Byte*  line = bitmap->buffer;
+    FT_UInt   xx;
+
+
+    if ( strength > 0 )
+      for ( height = (FT_UInt)bitmap->rows;
+            height > 0;
+            height--, line += bitmap->pitch )
+    {
+
+      for ( xx = 1; xx < width - 1; xx += 1 )
+      {
+        if ( abs( line[xx-1] - line[xx] ) < 20 ||
+             abs( line[xx+1] - line[xx] ) < 20 )
+        line [xx] = pseudo_gamma( line [xx], strength ) ;
+      }
+    }
+  }
+#endif
+
+  /* Fringe filter */
+  static void
+  _ft_lcd_fringe_filter ( FT_Bitmap*      bitmap,
+                          FT_Render_Mode  mode,
+                          FT_UInt         strength,
+                          FT_Library      library )
+  {
+
+    FT_UInt   width   = (FT_UInt)bitmap->width;
+    FT_UInt   height  = (FT_UInt)bitmap->rows;
+    FT_Byte*  new_line;
+    FT_Byte*  line = bitmap->buffer;
+    FT_Bitmap   new_bitmap;
+
+
+    FT_Bitmap_Init(&new_bitmap);
+
+    line = bitmap->buffer;
+    FT_Bitmap_Copy( library, bitmap, &new_bitmap );
+    new_line = (&new_bitmap)->buffer;
+
+    for ( height = (FT_UInt)bitmap->rows;
+          height > 0;
+          height--, line += bitmap->pitch, new_line += bitmap->pitch )
+    {
+      /* Threshold set to 1/2 pixel intensity */
+      FT_UInt  xx, threshold = 128;
+
+      /* Hack to make this work when bitmap is at first or last line */
+      FT_Int   fudge = bitmap->pitch * (height == (FT_UInt)bitmap->rows);
+
+      FT_Byte*  prevline = line - bitmap->pitch + fudge;
+      FT_Byte*  nextline = line + bitmap->pitch;
+
+
+      for ( xx = 1; xx < width - 1; xx += 1 )
+      {
+        /* subpixel grid       sp11 sp21 sp31   */
+        /* where sp22 is       sp12 sp22 sp32   */
+        /* current subpixel.   sp13 sp23 sp33   */
+
+        FT_Int prevtotal, nexttotal, lefttotal, righttotal, sidesdiff,
+          leftdiff, rightdiff, prevdiff, nextdiff, sp11, sp21, sp31,
+          sp12, sp22, sp32, sp13, sp23, sp33;
+
+        sp12 = line [xx-1];
+        sp22 = line [xx];
+        sp32 = line [xx+1];
+
+        /* if at max height fake out some values */
+        if ( height == (FT_UInt)bitmap->rows )
+        {
+          prevtotal = sp11 = sp21 = sp31 = 0;
+          prevdiff = sp22;
+          lefttotal = sp12 + sp13;
+          righttotal = sp32 + sp33;
+        }
+        else
+        {
+          prevtotal = prevline[xx-1] + prevline[xx] + prevline[xx+1];
+          sp11 = prevline [xx-1];
+          sp21 = prevline [xx];
+          sp31 = prevline [xx+1];
+          prevdiff = sp22 - sp21;
+          lefttotal = sp11 + sp12 + sp13;
+          righttotal = sp31 + sp32 + sp33;
+        }
+
+        /* if at min height fake out some values */
+        if ( height == 1 )
+        {
+          nexttotal = sp13 = sp23 = sp33 = 0;
+          nextdiff = sp22;
+          lefttotal = sp11 + sp12;
+          righttotal = sp31 + sp32;
+        }
+        else
+        {
+          nexttotal = nextline[xx-1] + nextline[xx] + nextline[xx+1];
+          sp13 = nextline [xx-1];
+          sp23 = nextline [xx];
+          sp33 = nextline [xx+1];
+          nextdiff = sp23 - sp22;
+          lefttotal = sp11 + sp12 + sp13;
+          righttotal = sp31 + sp32 + sp33;
+        }
+
+        sidesdiff = lefttotal - righttotal;
+        leftdiff = sp22 - sp12;
+        rightdiff = sp32 - sp22;
+
+        if ( sidesdiff < 0 )
+          sidesdiff *= -1;
+
+        if ( prevdiff < 0 )
+          prevdiff *= -1;
+
+        if ( nextdiff < 0 )
+          nextdiff *= -1;
+
+        if ( leftdiff < 0 )
+          leftdiff *= -1;
+
+        if ( rightdiff < 0 )
+          rightdiff *= -1;
+
+        /* if the current subpixel is less than threshold, and varies only
+          slightly to left or right, lighten it */
+        if ( sp22 <= threshold && sp22 > 0       &&
+             ( leftdiff < 10 || rightdiff < 10 ) )
+        {
+          /* A pixel is horizontally isolated if: */
+          /* 1: All upper adjecent subpixels are >= threshold and all lower
+             adjacent ones are essentially white */
+          if ( prevtotal >= nexttotal &&
+               sp11 >= threshold      &&
+               sp21 >= threshold      &&
+               sp31 >= threshold      &&
+               sp13 < 2               &&
+               sp23 < 2               &&
+               sp33 < 2               )
+
+          {
+            new_line[xx] -= ( new_line[xx] * strength ) / 100;
+
+            if ( leftdiff < 10 )
+              /* OPPORTUNITY FOR IMPROVEMENT  - keep going left until 255? */
+              new_line[xx-1] -= ( new_line[xx-1] * strength ) / 200;
+
+            if ( rightdiff < 10 )
+              /* OPPORTUNITY FOR IMPROVEMENT */
+              new_line[xx+1] -= ( new_line[xx+1] * strength ) / 200;
+          }
+          else if ( nexttotal > prevtotal &&
+                    /* 2: the inverse of above */
+                    sp13 >= threshold     &&
+                    sp23 >= threshold     &&
+                    sp33 >= threshold     &&
+                    sp11 < 2              &&
+                    sp21 < 2              &&
+                    sp31 < 2              )
+          {
+            new_line[xx] -= ( new_line[xx] * strength ) / 100;
+
+            if ( leftdiff < 10 )
+              /* OPPORTUNITY FOR IMPROVEMENT - keep going left until 255?  */
+              new_line[xx-1] -= ( new_line[xx-1] * strength ) / 200;
+
+            if ( rightdiff < 10 )
+              /* OPPORTUNITY FOR IMPROVEMENT */
+              new_line[xx+1] -= ( new_line[xx+1] * strength ) / 200;
+          }
+        }
+        /* otherwise if the current subpixel is more than threshold, and varies
+          slightly to left or right, darken it */
+        else if ( sp22 > threshold    &&
+                  sp22 < 255          &&
+                  ( leftdiff < 10  ||
+                    rightdiff < 10 )  )
+        {
+          if ( sp11 <= 2             &&
+               sp21 <= 2             &&
+               sp31 <= 2             &&
+               sp13 >= threshold     &&
+               sp23 >= threshold     &&
+               sp33 >= threshold     &&
+               prevtotal < nexttotal )
+            new_line[xx] += ( ( 255 - new_line[xx] ) * strength ) / 100;
+
+          else if ( sp13 <= 2             &&
+                    sp23 <= 2             &&
+                    sp33 <= 2             &&
+                    nexttotal < prevtotal &&
+                    sp11 >= threshold     &&
+                    sp21 >= threshold     &&
+                    sp31 >= threshold     )
+            new_line[xx] += ( ( 255 - new_line[xx] ) * strength ) / 100;
+
+        }
+      }
+    }
+    FT_Bitmap_Copy( library, &new_bitmap, bitmap );
+    FT_Bitmap_Done( library, &new_bitmap );
+  }
+
+
+  /* Grayscale filter */
+  static void
+  _ft_lcd_grayscale_filter ( FT_Bitmap*      bitmap,
+                             FT_Render_Mode  mode,
+                             FT_UInt         strength,
+                             FT_Library      library )
+  {
+
+    FT_UInt   width   = (FT_UInt)bitmap->width;
+    FT_UInt   height  = (FT_UInt)bitmap->rows;
+    FT_Byte*  line    = bitmap->buffer;
+
+
+    for ( height = (FT_UInt)bitmap->rows;
+          height > 0;
+          height--, line += bitmap->pitch )
+    {
+      FT_UInt xx;
+
+
+      for ( xx = 0; xx < width - 1; xx += 3 )
+      {
+        FT_UInt total = line [xx] + line [xx + 1] + line [xx + 2];
+        line[xx] =   ( ( 100 - strength ) * line[xx]
+                       + strength * ( total / 3 ) ) / 100;
+        line[xx+1] = ( ( 100 - strength ) * line[xx+1]
+                       + strength * ( total / 3 ) ) / 100;
+        line[xx+2] = ( ( 100 - strength ) * line[xx+2]
+                       + strength * ( total / 3 ) ) / 100;
+      }
+    }
+  }
+
+/*
+  These need to be in sync with params inside ftinf.c
+  (not ideal but perhaps better than making these public)
+ */
+#define STEM_WIDTH_2_PPEM 18
+#define MAX_PPEM 100
+
+  typedef struct  Stem_Segment_
+  {
+    FT_Long       x1;
+    FT_Long       x2;
+    FT_Int        y;
+  } Stem_Segment;
+
+  typedef struct  Stem_Center_
+  {
+    FT_Long       x;
+    FT_Long       y;
+    FT_Long       w;
+    FT_Long       x1;
+    FT_Long       x2;
+  } Stem_Center;
+
+  typedef struct  Stem_
+  {
+    FT_Long       center;
+    FT_Long       count;
+    FT_Long       rcount; /* used to count within a range in possible stems */
+    FT_Long       width;
+    FT_Long       height;
+    FT_Short      zone;  /* 1 2 or 3 */
+    FT_Bool       generated;
+  } Stem;
+
+  static void
+  swap_stem ( Stem* s1, Stem* s2 )
+  {
+    Stem s;
+    s.center = s1->center;
+    s.count  = s1->count;
+    s.rcount = s1->rcount;
+    s.width  = s1->width;
+    s.zone   = s1->zone;
+    s.generated = s1->generated;
+
+    s1->center = s2->center;
+    s1->count  = s2->count;
+    s1->rcount = s2->rcount;
+    s1->width  = s2->width;
+    s1->zone   = s2->zone;
+    s1->generated = s2->generated;
+
+    s2->center = s.center;
+    s2->count  = s.count;
+    s2->rcount = s.rcount;
+    s2->width  = s.width;
+    s2->zone   = s.zone;
+    s2->generated = s.generated;
+  }
+
+  /* Stem alignment for bitmaps;  A hack with very nice results */
+  /* Ideally this could be implemented on the outline, prior to
+   * rasterization.  Possible future enhancement is to use the
+   * warper code to achieve this */
+  static void
+  _lcd_stem_align ( FT_Bitmap*      bitmap,
+                    FT_Render_Mode  mode,
+                    FT_GlyphSlot    slot,
+                    FT_Long*        translate_value,
+                    float*          scale_value,
+                    FT_UInt         alignment_strength,
+                    FT_UInt         fitting_strength,
+                    float*          embolden_value
+                  )
+  {
+    FT_UInt         width   = (FT_UInt)bitmap->width;
+    FT_UInt         height  = (FT_UInt)bitmap->rows;
+
+    Stem_Segment*   segments;
+    Stem_Segment*   leftmost_segment;
+    Stem_Segment*   rightmost_segment;
+    Stem_Segment*   leftmost_segment_not_extrema;
+    Stem_Segment*   rightmost_segment_not_extrema;
+    Stem*           stems;
+    Stem*           possible_stems;
+    Stem*           leftmost_stem;
+    Stem*           rightmost_stem;
+    Stem_Data*      known_stem_values;
+    Stem_Center*    centers;
+    FT_Long         leftmost_point = width * 256;
+    FT_Long         rightmost_point = 0;
+    FT_Long         leftmost_point_not_extrema = width * 256;
+    FT_Long         rightmost_point_not_extrema = 0;
+    FT_Long         num_segments = 0;
+    FT_Long         num_centers = 0;
+    FT_Long         *stem_centers;
+    FT_UInt         h;
+    FT_ULong        valid_stems = 0, valid_possible_stems = 0;
+    FT_Long         center, stem_matches, stem_matches_ledge;
+    FT_Long         stem_matches_redge, next_center, last_matching_center;
+    FT_Long         last_matching_ledge, last_matching_redge, this_center;
+    FT_Int          max_strength;
+    FT_Byte*        line = bitmap->buffer;
+    FT_UInt         current_value = 0;
+    FT_UInt         xx;
+    FT_Long         linearHoriAdvance = slot->linearHoriAdvance >> 10;
+
+    FT_Int          m_horiBearingX = slot->metrics.horiBearingX;
+    FT_Int          m_horiAdvance = slot->metrics.horiAdvance;
+    FT_Int          m_width = slot->metrics.width;
+    FT_Pos          one_pixel = 768;
+    FT_Pos          one_third_pixel = 256;
+    FT_Int          columns_per_pixel = 3;
+    /*FT_Int          extra_columns = 6;*/
+
+    /* on / off flags for testing different features */
+    FT_Bool         strategy_translate_using_closest_stem = TRUE;
+    FT_Bool         strategy_scale_to_closest_centers = FALSE;
+    FT_Bool         strategy_scale_to_closest_centers_up_only = FALSE;
+    FT_Bool         strategy_always_use_distance_ceiling = FALSE;
+    FT_Bool         strategy_auto_change_center_offset = TRUE;
+    FT_Bool         strategy_use_m_control = FALSE;
+    FT_Bool         strategy_correct_out_of_bounds_outlines = FALSE;
+    FT_Bool         strategy_also_use_edge_detection_for_stems = FALSE;
+    FT_Bool         strategy_use_strengths = TRUE;
+    FT_Bool         strategy_synthesize_stems = FALSE;
+    FT_Bool         strategy_bearing_correction = TRUE;
+    FT_Bool         strategy_use_d_correction = TRUE;
+    FT_Bool         strategy_fit_to_width = FALSE;
+    /*FT_Bool         strategy_center_glyph = FALSE;*/
+
+    const FT_Int    MIN_PPEM = 7;
+    /*const FT_Int    MAX_PPEM = 100;*/
+    const FT_Int    MAX_STEMS = 3;
+    FT_Int          ppem = 0;
+
+    Stem_Data       stem_data;
+
+    /* reset to default */
+    *scale_value = 1.0;
+
+    /* Simply return in odd cases where these don't seem to be set */
+    /* Flash and some pdf viewers will crash otherwise */
+    if ( !slot->face                       ||
+         !slot->face->size                 ||
+         !slot->face->size->metrics.x_ppem )
+      return;
+
+    if ( slot->face->size->metrics.x_ppem > MAX_PPEM )
+      return;
+
+    if ( slot->face->size->metrics.x_ppem < MIN_PPEM )
+      return;
+
+    if ( !FT_IS_SCALABLE( slot->face ) )
+      return;
+
+    ppem = slot->face->size->metrics.x_ppem;
+
+    if ( ppem < 9 )
+      return;
+    if ( ppem > 20 )
+        strategy_use_m_control = TRUE;
+
+    /* only perform alignment on styles we know, that aren't bold or italic */
+    /* perhaps detection could be added on those that are not set? */
+    /* Require certain ppems for narrow and light fonts */
+    if( slot->face->style_name )
+    {
+      if ( stricmp( slot->face->style_name, "Italic" )            ||
+           stricmp( slot->face->style_name, "Oblique" )           ||
+           stricmp( slot->face->style_name, "Script" )            ||
+           stricmp( slot->face->style_name, "Handwriting" )       ||
+           stricmp( slot->face->style_name, "Bold" )              ||
+           stricmp( slot->face->style_name, "Black" )             ||
+           ( ( stricmp( slot->face->style_name, "Extra Thin" )  ||
+               stricmp( slot->face->style_name, "Extra Light" ) ) &&
+             ppem < 10 )                                             ||
+           ( stricmp( slot->face->style_name, "Thin" )
+               && ppem < 10 )                                        ||
+           ( stricmp( slot->face->style_name, "Light" )
+               && ppem < 10 )                                        ||
+           ( stricmp( slot->face->style_name, "Narrow" )
+               && ppem < 15 )                                        ||
+           ( stricmp( slot->face->style_name, "Condensed" )
+               && ppem < 20 )                                        )
+            return;
+    }
+
+    if( slot->face->family_name )
+    {
+      if ( stricmp( slot->face->family_name, "Italic" )            ||
+           stricmp( slot->face->family_name, "Oblique" )           ||
+           stricmp( slot->face->family_name, "Script" )            ||
+           stricmp( slot->face->family_name, "Handwriting" )       ||
+           stricmp( slot->face->family_name, "Bold" )              ||
+           stricmp( slot->face->family_name, "Black" )             ||
+           ( ( stricmp( slot->face->family_name, "Extra Thin" )  ||
+               stricmp( slot->face->family_name, "Extra Light" ) ) &&
+             ppem < 10 )                                              ||
+           ( stricmp( slot->face->family_name, "Thin" )
+               && ppem < 10 )                                         ||
+           ( stricmp( slot->face->family_name, "Light" )
+               && ppem < 10 )                                         ||
+           ( stricmp( slot->face->family_name, "Narrow" )
+               && ppem < 15 )                                         ||
+           ( stricmp( slot->face->family_name, "Condensed" )
+               && ppem < 20 )                                         )
+            return;
+    }
+    else if ( slot->face->style_flags )
+    {
+      if ( slot->face->style_flags & FT_STYLE_FLAG_ITALIC ||
+           slot->face->style_flags & FT_STYLE_FLAG_BOLD   ||
+           FT_IS_TRICKY( slot->face )                     )
+        return;
+    }
+    else return;
+
+    if ( mode != FT_RENDER_MODE_LCD )
+    {
+      columns_per_pixel = 1;
+      one_pixel = 256;
+      one_third_pixel = 85;
+      /*extra_columns = 0;*/
+      /* until this can be figured out just return */
+      /* There are issues with missing glyphs */
+      return;
+    }
+
+    known_stem_values=&stem_data;
+    if ( ftinf && ftinf->use_known_settings_on_selected_fonts )
+    {
+      ftinf_fill_stem_values( known_stem_values, slot->face->family_name, ppem, TRUE );
+      /* translate value may be set for < 10 */
+      if (known_stem_values->stem_translating_only > -1024 )
+      {
+          *translate_value = known_stem_values->stem_translating_only;
+          return;
+      }
+      if( known_stem_values->bearing_correction == FALSE )
+          strategy_bearing_correction = FALSE;
+    } else
+        ftinf_fill_stem_values( known_stem_values, slot->face->family_name, ppem, FALSE );
+
+    if ( known_stem_values->use_100 ||
+         known_stem_values->m >= 0  )
+    {
+      alignment_strength = fitting_strength = 100;
+      strategy_use_m_control = TRUE;
+    }
+
+    if ( known_stem_values->edge_detection )
+      strategy_also_use_edge_detection_for_stems = TRUE;
+
+    /* Allocate */
+    segments = NULL;
+    leftmost_segment = (Stem_Segment*) malloc( 4*sizeof ( Stem_Segment ) );
+    leftmost_segment_not_extrema = leftmost_segment+1;
+    rightmost_segment = leftmost_segment+2;
+    rightmost_segment_not_extrema = leftmost_segment+3;
+
+    stems          = (Stem*) malloc ( (2*MAX_STEMS+2) * sizeof ( Stem ) );
+    possible_stems = stems+MAX_STEMS;
+    leftmost_stem  = possible_stems+MAX_STEMS;
+    rightmost_stem = leftmost_stem + 1;
+    centers        = NULL;
+
+    if ( verbose )
+      printf("\n");
+
+    /* Initialize */
+    stem_centers=(FT_Long*)calloc( width * 256, sizeof(stem_centers[0]) );
+
+    rightmost_segment->x1 = 0;
+    rightmost_segment->x2 = 0;
+    rightmost_segment->y  = 0;
+    leftmost_segment->x1  = 99999999;
+    leftmost_segment->x2  = 0;
+    leftmost_segment->y   = 0;
+
+    rightmost_segment_not_extrema->x1 = 0;
+    rightmost_segment_not_extrema->x2 = 0;
+    rightmost_segment_not_extrema->y  = 0;
+    leftmost_segment_not_extrema->x1  = 99999999;
+    leftmost_segment_not_extrema->x2  = 0;
+    leftmost_segment_not_extrema->y   = 0;
+
+    /* Locate stem centers for later processing */
+    for ( h = (FT_UInt)bitmap->rows; h > 0; h--, line += bitmap->pitch )
+    {
+      current_value = 0;
+      /* Calculate various sums and stem widths of glyph */
+      for ( xx = 0; xx < width; xx += 1 )
+      {
+        /* Reallocate (in blocks of 64) */
+        if( num_segments % 64 == 0 )
+            segments = (Stem_Segment*) realloc
+                ( segments, ( num_segments + 64 ) * sizeof ( Stem_Segment ) );
+
+        /* if line is white, and now has color, it's the start of a stem */
+        if ( current_value == 0 && line[xx] > 0 )
+        {
+          /* start of stem */
+          segments[num_segments].x1 = 256 * xx + ( 255 - line[xx] );
+          segments[num_segments].y = h;
+        }
+
+        /* otherwise, if it's currently black and the new value is 0,
+           it's the end of a stem */
+        else if ( ( current_value > 0 && line[xx] == 0 )   ||
+                  ( current_value > 0 && xx == width - 1 ) )
+        {
+          FT_Long stem_center_x;
+          segments[num_segments].x2 = 256 * ( xx - 1 ) + line[xx-1];
+
+          if ( xx == width - 1 )
+            segments[num_segments].x2 += line[xx];
+
+          /*stem center is average of start and end of stem */
+          stem_center_x = ( segments[num_segments].x2
+                            + segments[num_segments].x1 ) / 2;
+
+          /* Reallocate (in blocks of 32) */
+          if( num_centers % 32 == 0 )
+              centers = (Stem_Center*) realloc
+                  ( centers, ( num_centers + 32 ) * sizeof ( Stem_Center ) );
+          centers[num_centers].x = stem_center_x;
+          centers[num_centers].y = h;
+          centers[num_centers].x1 = segments[num_segments].x1;
+          centers[num_centers].x2 = segments[num_segments].x2;
+
+          num_centers++;
+
+          stem_centers[stem_center_x] += 1;
+
+          /* Find left and rightmost points for later calculations */
+          /* OR - Favor ones that aren't on the top or bottom if   */
+          /* possible to prevent v and w from getting caught later */
+          if ( segments[num_segments].x1 < leftmost_segment->x1      ||
+               ( segments[num_segments].y > 1                      &&
+                 segments[num_segments].y < height                 &&
+                 segments[num_segments].x1 == leftmost_segment->x1 ) )
+          {
+            leftmost_segment->x1 = segments[num_segments].x1;
+            leftmost_segment->x2 = segments[num_segments].x2;
+            leftmost_segment->y = h;
+          }
+          if ( segments[num_segments].x2 > rightmost_segment->x2      ||
+               ( segments[num_segments].y > 1                       &&
+                 segments[num_segments].y < height                  &&
+                 segments[num_segments].x1 == rightmost_segment->x1 ) )
+          {
+            rightmost_segment->x1 = segments[num_segments].x1;
+            rightmost_segment->x2 = segments[num_segments].x2;
+            rightmost_segment->y = h;
+          }
+
+          if ( segments[num_segments].x1
+                 < leftmost_segment_not_extrema->x1      ||
+               ( segments[num_segments].y > 1          &&
+                 segments[num_segments].y < height     &&
+                 segments[num_segments].x1
+                   == leftmost_segment_not_extrema->x1 &&
+                 h < (FT_UInt)bitmap->rows && h > 0    ) )
+          {
+            leftmost_segment_not_extrema->x1 = segments[num_segments].x1;
+            leftmost_segment_not_extrema->x2 = segments[num_segments].x2;
+            leftmost_segment_not_extrema->y = h;
+          }
+          if ( segments[num_segments].x2
+                 > rightmost_segment_not_extrema->x2      ||
+               ( segments[num_segments].y > 1           &&
+                 segments[num_segments].y < height      &&
+                 segments[num_segments].x1
+                   == rightmost_segment_not_extrema->x1 &&
+                 h < (FT_UInt)bitmap->rows && h > 0     ) )
+          {
+            rightmost_segment_not_extrema->x1 = segments[num_segments].x1;
+            rightmost_segment_not_extrema->x2 = segments[num_segments].x2;
+            rightmost_segment_not_extrema->y = h;
+          }
+
+          if ( segments[num_segments].x1 < leftmost_point )
+            leftmost_point = segments[num_segments].x1;
+
+          if ( segments[num_segments].x2 > rightmost_point )
+            rightmost_point = segments[num_segments].x2;
+
+          if ( segments[num_segments].x1 < leftmost_point_not_extrema &&
+               h < (FT_UInt)bitmap->rows && h > 0                     )
+            leftmost_point_not_extrema = segments[num_segments].x1;
+
+          if ( segments[num_segments].x2 > rightmost_point_not_extrema &&
+               h < (FT_UInt)bitmap->rows && h > 0                      )
+            rightmost_point_not_extrema = segments[num_segments].x2;
+
+          num_segments++;
+        }
+        /* else - other conditions - need some error checking here */
+        current_value = line[xx];
+      }
+    }
+
+    /* initialize */
+    for ( xx = 0; xx < MAX_STEMS; xx +=1 )
+    {
+      stems[xx].center = 0;
+      stems[xx].count = 0;
+      stems[xx].width = 0;
+      stems[xx].height = 0;
+      possible_stems[xx].center = 0;
+      possible_stems[xx].count = 0;
+      possible_stems[xx].width = 0;
+      possible_stems[xx].height = 0;
+    }
+
+    valid_stems = 0;
+    valid_possible_stems = 0;
+
+    /* Determine which centers belong to stems */
+    center = 0;
+
+    while ( center < num_centers )
+    {
+      /* slope at within which to consider a point part of a stem */
+      /*const FT_UInt slope = 1;
+      const FT_UInt topslope = (256 * 3) / 10; */
+
+      /* 10 to 20 with 4 matches seems good,                   */
+      /* but 1 or 2 with 3 stems needs to somehow get included */
+      FT_Int deviation1 = 5;
+      FT_Int deviation2=-1, requirement1 = 4, stem_match_requirement = 3;
+      FT_Int center_difference_in_height;
+      FT_Int center_difference_in_width, valid_center_average;
+      FT_Int smallest_width_ledge, smallest_width_redge;
+      FT_Int x1_difference_in_width, x2_difference_in_width;
+      FT_Bool no_gap_found = FALSE;
+      FT_Bool no_gap_found_ledge = FALSE;
+      FT_Bool no_gap_found_redge = FALSE;
+      FT_Bool stem_detected = FALSE;
+      FT_Int set_width_to, set_center_to;
+
+      /* seems to not do damage */
+      /* May not be effective */
+      requirement1 = height / 4;
+      if ( requirement1 < 5 )
+        requirement1 = 5;
+      deviation1 = 20;
+      deviation2 = 20;
+
+      if ( columns_per_pixel == 1 )
+        deviation1 = deviation2 = 10;
+
+      if ( (FT_Int)bitmap->rows <= 6 )
+        deviation1 = 25;
+
+      if ( (FT_Int)bitmap->rows <= 6 )
+        deviation2 = 25;
+
+      if ( columns_per_pixel == 1    &&
+           (FT_Int)bitmap->rows <= 6 )
+        deviation1 = deviation2 = 12;
+
+      valid_center_average = 0;
+
+      no_gap_found = no_gap_found_ledge = no_gap_found_redge = FALSE;
+      stem_detected = FALSE;
+
+      if ( ppem < 11 )
+        requirement1 = 4;
+
+      if ( ppem > 18 )
+      {
+        stem_match_requirement = height / 4;
+        if ( stem_match_requirement < 3 )
+          stem_match_requirement = 3;
+      }
+
+      smallest_width_ledge = smallest_width_redge = width * 256;
+      stem_matches = 0;
+      stem_matches_ledge = 0;
+      stem_matches_redge = 0;
+      last_matching_center = -1;
+      last_matching_ledge = -1;
+      last_matching_redge = -1;
+
+      /* set currently looked at center to center value */
+      this_center = center;
+      next_center = 0;
+
+      /* For each center, compare with all other centers to see if others */
+      /* match the properties of this one                                 */
+      while ( next_center < num_centers )
+      {
+
+        /* calculate differences */
+        center_difference_in_width = abs ( centers[this_center].x
+                                             - centers[next_center].x );
+        center_difference_in_height = abs ( centers[this_center].y
+                                              - centers[next_center].y );
+        x1_difference_in_width = abs ( centers[this_center].x1
+                                         - centers[next_center].x1 );
+        x2_difference_in_width = abs ( centers[this_center].x2
+                                         - centers[next_center].x2 );
+
+
+        /* property - stem center points that align                        */
+        /* if the center is within range, the center is less than          */
+        /* 1/2 the height away, and at least one edge is also within range */
+        if ( center_difference_in_width
+               < center_difference_in_height * deviation1     &&
+             center_difference_in_height
+               <= (FT_Int)bitmap->rows / 2                    &&
+             /* prevents w from getting caught ---- but also kills m */
+             ( x1_difference_in_width
+                 < center_difference_in_height * deviation2 ||
+               x2_difference_in_width
+                 < center_difference_in_height * deviation2 ) )
+        {
+          stem_matches += 1;
+          valid_center_average += centers[next_center].x;
+
+          /* try to find where the matching centers are far apart */
+          if ( last_matching_center >= 0 &&
+               abs( centers[last_matching_center].y
+                      - centers[next_center].y ) >= (FT_Int)bitmap->rows / 2 )
+
+          /* try to find where matching centers are next to each other */
+          if ( last_matching_center >= 0 &&
+               abs( centers[last_matching_center].y
+                      - centers[next_center].y ) == 1 )
+            no_gap_found = TRUE;
+
+          last_matching_center = next_center;
+        }
+
+        if ( strategy_also_use_edge_detection_for_stems )
+        {
+          /* property - stem left edge points that align */
+          /* if the center is within range,              */
+          /* the center is less than 1/2 the height away */
+          if ( x1_difference_in_width
+                 < center_difference_in_height * deviation1            &&
+               center_difference_in_height <= (FT_Int)bitmap->rows / 2 )
+          {
+            stem_matches_ledge += 1;
+            /* may not need for edges */
+            /*valid_center_average += centers[next_center].x;  */
+
+            if ( centers[next_center].x2 - centers[next_center].x1
+                   < smallest_width_ledge )
+              smallest_width_ledge = centers[next_center].x2
+                                       - centers[next_center].x1;
+
+            /* try to find where the matching centers are far apart */
+            if ( last_matching_ledge >= 0            &&
+                 abs( centers[last_matching_ledge].y
+                        - centers[next_center].y)
+                   >= (FT_Int)bitmap->rows / 2       )
+
+            /* try to find where matching centers are next to each other */
+            if ( last_matching_ledge >= 0               &&
+                 abs( centers[last_matching_ledge].y
+                        - centers[next_center].y ) == 1 )
+              no_gap_found_ledge = TRUE;
+            last_matching_ledge = next_center;
+          }
+        }
+
+        if ( strategy_also_use_edge_detection_for_stems )
+        {
+          /* property - stem right edge points that align               */
+          /* if the center is within range, the center is less than 1/2 */
+          /* the height away                                            */
+          if ( x2_difference_in_width
+                 < center_difference_in_height * deviation1 &&
+               center_difference_in_height
+                 <= (FT_Int)bitmap->rows / 2                )
+          {
+            stem_matches_redge += 1;
+            /* may not need for edges */
+            /*valid_center_average += centers[next_center].x; */
+
+            if ( centers[next_center].x2 - centers[next_center].x1
+                   < smallest_width_redge )
+              smallest_width_redge = centers[next_center].x2
+                                       - centers[next_center].x1;
+
+            /* try to find where the matching centers are far apart */
+            if ( last_matching_redge >= 0 &&
+                 abs( centers[last_matching_redge].y
+                       - centers[next_center].y ) >= (FT_Int)bitmap->rows / 2 )
+
+            /* try to find where matching centers are next to each other */
+            if ( last_matching_redge >= 0 &&
+                 abs( centers[last_matching_redge].y
+                        - centers[next_center].y ) == 1 )
+              no_gap_found_redge = TRUE;
+
+            last_matching_redge = next_center;
+          }
+        }
+
+        next_center++;
+      }
+
+      if ( stem_matches > 0 )
+        valid_center_average /= stem_matches;
+
+      if ( ( stem_matches >= stem_match_requirement             ||
+             ( ( (FT_Int)bitmap->rows <= 6 || ppem < 11 )   &&
+                 stem_matches >= 2                          &&
+                 abs ( valid_center_average
+                       - centers[center].x) < deviation1 /2 ) ||
+            /* try to catch tightly aligned stuff where the matching centers */
+            /* are next to each other only                                   */
+             ( stem_matches == 2                            &&
+                 abs( valid_center_average
+                      - centers[center].x) <= deviation1 /2 &&
+                 no_gap_found                               &&
+                 ppem < 18 )                                    )     &&
+            /* catches things like times 16 u but gets a lot of w's too */
+            /* stem width is less than 1/3 of the bitmap width,         */
+            /* or bitmap_width is small                                 */
+            ( centers[center].x2 - centers[center].x1
+                   < (m_horiAdvance * 12) / 2                       ||
+                m_horiAdvance * 12 <= columns_per_pixel * one_pixel ) )
+      {
+        stem_detected = TRUE;
+        set_width_to  = centers[center].x2 - centers[center].x1;
+        set_center_to = centers[center].x;
+      }
+
+      /* see if edges found anything */
+      if ( strategy_also_use_edge_detection_for_stems && !stem_detected )
+      {
+        /* Require no gap for edges */
+        /* stem width less than 1/3 bitmap width, or bitmap_width is small */
+        /* The stem occurs on the left side of glyph only */
+        if ( ( stem_matches_ledge >= stem_match_requirement &&
+               no_gap_found_ledge                           )        &&
+             ( centers[center].x2 - centers[center].x1
+                 < ( m_horiAdvance * 12 ) / 2 ||
+               m_horiAdvance * 12 <= columns_per_pixel * one_pixel ) &&
+             centers[center].x < ( m_horiAdvance * 12 ) / 2          )
+        {
+          stem_detected = TRUE;
+          set_width_to  = smallest_width_ledge;
+          set_center_to = centers[center].x1 + set_width_to / 2;
+          stem_matches  = stem_matches_ledge;
+        }
+        /* Require no gap for edges                                           */
+        /* stem width is less than 1/3 bitmap width, or bitmap_width is small */
+        /* The stem occurs on the right side of glyph only                    */
+        else if ( ( stem_matches_redge >= stem_match_requirement  &&
+                    no_gap_found_redge                            )       &&
+                  ( centers[center].x2 - centers[center].x1
+                      < ( m_horiAdvance * 12 ) / 2 ||
+                    m_horiAdvance * 12 <= columns_per_pixel * one_pixel ) &&
+                  centers[center].x > (m_horiAdvance * 12) / 2            )
+        {
+          stem_detected = TRUE;
+          set_width_to  = smallest_width_redge;
+          set_center_to = centers[center].x2 - set_width_to / 2;
+          stem_matches  = stem_matches_redge;
+        }
+      }
+
+
+      /*store and/or replace highest occurrences with 3 or more centers */
+      /* because this matched, it will become the top dog regardless */
+      if ( stem_detected && (stem_matches > possible_stems[0].height) )
+      {
+        /* if this is the first stem just go ahead */
+        if ( valid_possible_stems == 0 )
+        {
+          valid_possible_stems = 1;
+          possible_stems[0].center = set_center_to;
+          possible_stems[0].count  = stem_matches;
+          possible_stems[0].width  = set_width_to;
+          possible_stems[0].height = stem_matches;
+        }
+
+        /* otherwise, if there is already a stem */
+        else if ( valid_possible_stems == 1 )
+        {
+          /* if stem is within range of existing one, replace existing one */
+
+          /* if the stem isn't within the range of this one swap it with   */
+          /* next one first                                                */
+          if ( abs ( set_center_to - possible_stems[0].center )
+                 >= one_pixel * 2 )
+          {
+            swap_stem ( &possible_stems[0], &possible_stems[1] );
+            valid_possible_stems = 2;
+          }
+          possible_stems[0].center = set_center_to;
+          possible_stems[0].count  = stem_matches;
+          possible_stems[0].width  = set_width_to;
+          possible_stems[0].height = stem_matches;
+        }
+
+        /* otherwise if there are already 2 stems */
+        else if ( valid_possible_stems >= 2 )
+        {
+          /* if the stem is within the range of existing one, replace     */
+          /* existing one                                                 */
+          if ( abs ( set_center_to - possible_stems[0].center )
+                 <= one_pixel * 2 )
+          {
+            possible_stems[0].center = set_center_to;
+            possible_stems[0].count  = stem_matches;
+            possible_stems[0].width  = set_width_to;
+            possible_stems[0].height = stem_matches;
+          }
+          /* if the stem isn't within the range of this one */
+          else
+          {
+            /* see if within range of next one and swap if so and proceed */
+            /* overwriting it                                             */
+            if ( abs ( set_center_to - possible_stems[1].center )
+                   <= one_pixel * 2 )
+              swap_stem ( &possible_stems[0], &possible_stems[1] );
+
+            /* otherwise see if in range of third one */
+            else if ( abs ( set_center_to - possible_stems[2].center )
+                        <= one_pixel * 2 )
+              swap_stem ( &possible_stems[0], &possible_stems[2] );
+
+            /* otherwise this is the new top dog, so demote everything */
+            else
+            {
+              swap_stem ( &possible_stems[1], &possible_stems[2] );
+              swap_stem ( &possible_stems[0], &possible_stems[1] );
+              valid_possible_stems += 1;
+            }
+            possible_stems[0].center = set_center_to;
+            possible_stems[0].count  = stem_matches;
+            possible_stems[0].width  = set_width_to;
+            possible_stems[0].height = stem_matches;
+          }
+        }
+      }
+
+      else if ( stem_matches > possible_stems[1].height &&
+                set_center_to != 0                      )
+      {
+
+        /* make sure it doesn't match the first stem */
+        if ( abs ( set_center_to - possible_stems[0].center ) >= one_pixel * 2 )
+        {
+
+          /* if this is the second stem */
+          if ( valid_possible_stems == 1 )
+            valid_possible_stems = 2;
+
+          /* otherwise if there is already a stem here */
+          else if ( valid_possible_stems >= 2 )
+          {
+            /* if it doesn't match the second stem, proceed to swap out    */
+            /* with the third.  if it does, replace it                     */
+            if ( abs ( set_center_to - possible_stems[1].center )
+                   >= one_pixel * 2 )
+            {
+              swap_stem ( &possible_stems[1], &possible_stems[2] );
+              valid_possible_stems +=1;
+            }
+          }
+          possible_stems[1].center = set_center_to;
+          possible_stems[1].count  = stem_matches;
+          possible_stems[1].width  = set_width_to;
+          possible_stems[1].height = stem_matches;
+        }
+      }
+
+      else if ( stem_matches > possible_stems[2].height &&
+                set_center_to != 0                      )
+      {
+        /* if it doesn't match the first or second one */
+        if ( abs( set_center_to - possible_stems[0].center) >= one_pixel * 2 &&
+             abs( set_center_to - possible_stems[1].center) >= one_pixel * 2 )
+        {
+          if ( valid_possible_stems == 2 )
+            valid_possible_stems += 1;
+
+          possible_stems[2].center = set_center_to;
+          possible_stems[2].count  = stem_matches;
+          possible_stems[2].width  = set_width_to;
+          possible_stems[1].height = stem_matches;
+        }
+      }
+
+      if ( valid_possible_stems > 3 )
+        valid_possible_stems = 3;
+
+      center++;
+    }
+
+    /* promote to stem */
+    if ( valid_possible_stems > 0 )
+    {
+      stems[0].center    = possible_stems[0].center;
+      stems[0].count     = possible_stems[0].count;
+      stems[0].width     = possible_stems[0].width;
+      stems[0].height    = possible_stems[0].height;
+      stems[0].generated = FALSE;
+      valid_stems++;
+    }
+
+    if ( valid_stems == 1         &&
+         valid_possible_stems > 1 )
+    {
+      stems[1].center    = possible_stems[1].center;
+      stems[1].count     = possible_stems[1].count;
+      stems[1].width     = possible_stems[1].width;
+      stems[1].height    = possible_stems[1].height;
+      stems[1].generated = FALSE;
+      valid_stems++;
+    }
+
+    if ( valid_stems == 2              &&
+         valid_possible_stems > 2      &&
+         possible_stems[2].center != 0 )
+    {
+      stems[2].center    = possible_stems[2].center;
+      stems[2].count     = possible_stems[2].count;
+      stems[2].width     = possible_stems[2].width;
+      stems[2].height    = possible_stems[2].height;
+      stems[2].generated = FALSE;
+      valid_stems++;
+    }
+
+    /* sort stems in x direction */
+    if ( valid_stems == 3 )
+    {
+      if ( stems[0].center > stems[1].center )
+        swap_stem ( &stems[0], &stems[1] );
+
+      if ( stems[0].center > stems[2].center )
+        swap_stem ( &stems[1], &stems[2] );
+
+      if ( stems[1].center > stems[2].center )
+        swap_stem ( &stems[1], &stems[2] );
+
+      if ( stems[0].center > stems[1].center )
+        swap_stem ( &stems[0], &stems[1] );
+
+      /* only look at first and last stem for now */
+      swap_stem ( &stems[1], &stems[2] );
+    }
+
+   /* synthesize stems - Works, but needs work */
+   if ( ( strategy_synthesize_stems      ||
+          known_stem_values->synth_stems ) &&
+          valid_stems  == 0                &&
+          ppem > 10                        )
+    {
+      /* if the leftmost segment's leftmost point is the same as the glyph's */
+      /* leftmost point, and it is of reasonable width, and is not on the    */
+      /* top or bottom of the bitmap                                         */
+      if ( leftmost_segment_not_extrema->x1
+             == leftmost_point_not_extrema             &&
+           abs ( leftmost_segment_not_extrema->x2
+                   - leftmost_segment_not_extrema->x1 )
+             < ( rightmost_point_not_extrema
+                   - leftmost_point_not_extrema ) / 3  &&
+           leftmost_segment_not_extrema->y < height    &&
+           leftmost_segment_not_extrema->y > 1         )
+      {
+        stems[valid_stems].center = ( leftmost_segment_not_extrema->x2
+                                        + leftmost_segment_not_extrema->x1 ) / 2;
+        stems[valid_stems].width = leftmost_segment_not_extrema->x2
+                                        - leftmost_segment_not_extrema->x1;
+        stems[valid_stems].generated = TRUE;
+        valid_stems += 1;
+      }
+
+
+      if ( rightmost_segment_not_extrema->x2
+             == rightmost_point_not_extrema             &&
+           abs ( rightmost_segment_not_extrema->x2
+                   - rightmost_segment_not_extrema->x1 )
+             < ( rightmost_point_not_extrema
+                   - leftmost_point_not_extrema ) / 3   &&
+           rightmost_segment_not_extrema->y < height    &&
+           rightmost_segment_not_extrema->y > 1         )
+      {
+        stems[valid_stems].center = ( rightmost_segment_not_extrema->x2
+                                      + rightmost_segment_not_extrema->x1 ) / 2;
+        stems[valid_stems].width = rightmost_segment_not_extrema->x2
+                                      - rightmost_segment_not_extrema->x1;
+        stems[valid_stems].generated = TRUE;
+        valid_stems += 1;
+      }
+
+    }
+
+    /* sort stems in x direction */
+    if ( valid_stems > 1 && stems[0].center > stems[1].center )
+      swap_stem ( &stems[0], &stems[1] );
+
+    if ( valid_stems == 0 && known_stem_values->stem_translating != 0 )
+    {
+      *translate_value += known_stem_values->stem_translating;
+
+      if ( strategy_use_strengths )
+      {
+        /* consider 1/2 pixel the max when strength is at 100%,
+           unless translate is already greater than that */
+        FT_Int strength_cutoff = 32;
+
+
+        if ( abs ( *translate_value ) > strength_cutoff)
+          strength_cutoff = *translate_value;
+
+        max_strength = ( strength_cutoff * alignment_strength ) / 100;
+
+        if ( *translate_value < -max_strength )
+          *translate_value = -max_strength;
+        else if  ( *translate_value > max_strength )
+          *translate_value = max_strength;
+      }
+    }
+    else
+    /* Start snapping */
+    {
+      FT_Int  center_offset;
+      FT_Int  modulus;
+      FT_Int  delta, delta2;
+      FT_Long stem_distance = 1, new_distance = 1;
+      FT_Int  distance_floor, distance_ceiling;
+      FT_Int  translate_value2 = 0;
+      FT_Int  main_stem = 0;
+      FT_Int  lbearing = m_horiBearingX * 12;
+      FT_Int  bitmap_stem_location = stems[0].center;
+      FT_Int  advance_stem_location = bitmap_stem_location
+                                        + lbearing - one_pixel;
+      FT_Int  advance_width = m_horiAdvance * 12;
+      FT_Int  original_advance_width = 12 * ( slot->linearHoriAdvance >> 10 );
+      FT_Int  glyph_width = rightmost_point - leftmost_point;
+      FT_Int  stem_width = stems[0].width;
+      FT_Int  advance_leftmost_location = leftmost_point
+                                            + lbearing - one_pixel;
+      FT_Int  advance_rightmost_location = rightmost_point
+                                             + lbearing - one_pixel;
+
+#define proposed_transformed_point(point) \
+  point * (float)(new_distance) / (float)(stem_distance) \
+  + *translate_value * 12 - ( stems[main_stem].center * (float)(new_distance) \
+  / (float)(stem_distance) - stems[main_stem].center)
+
+#define proposed_translated_point(point) point + *translate_value * 12
+
+      center_offset = one_pixel / 2;   /* half pixel */
+      modulus = one_pixel;            /* whole pixel */
+
+      /* Determine center_offset via known values */
+      if ( known_stem_values->stem_width >= 0 )
+      {
+        if ( known_stem_values->stem_width % 2 == 0 )
+          center_offset = 0;
+        else
+          center_offset = one_pixel / 2;
+      }
+      /* otherwise do intelligent guessing, if set */
+      else if ( strategy_auto_change_center_offset &&
+                ppem >= STEM_WIDTH_2_PPEM          &&
+                stems[0].width < one_pixel * 1.45  )
+        center_offset = one_pixel / 2;
+      else if ( strategy_auto_change_center_offset &&
+                ppem >= STEM_WIDTH_2_PPEM          &&
+                stems[0].width >= one_pixel * 1.45 &&
+                stems[0].width < one_pixel * 2.6   )
+        center_offset = 0;
+      else if ( strategy_auto_change_center_offset &&
+                ppem >= STEM_WIDTH_2_PPEM          &&
+                stems[0].width >= one_pixel * 2.6  &&
+                stems[0].width < one_pixel * 3.6   )
+        center_offset = one_pixel / 2;
+      else if ( strategy_auto_change_center_offset &&
+                ppem >= STEM_WIDTH_2_PPEM          )
+        center_offset =
+          ( one_pixel
+             * ( ( ( (int)( stems[0].width + one_pixel / 2 ) )
+                             / one_pixel ) % 2 ) ) / 2;
+
+      /* Snap to closest translate and scale values by default */
+      if ( valid_stems >= 1 )
+      {
+        /* closest snapping point for stem 0 */
+        delta = ( stems[0].center  + center_offset ) % modulus;
+
+        if ( delta < modulus / 2 )
+          /* snap left */
+          *translate_value = -delta / ( columns_per_pixel * 4 );
+        else
+           /* snap right */
+          *translate_value = ( modulus - delta ) / ( columns_per_pixel * 4 );
+      }
+
+      if ( strategy_use_d_correction )
+      {
+        /* if the only stem is in the last 1/3 of glyph width, the advance */
+        /* is 6 pixels, the ppem 11, and doing so doesn't violate bitmap , */
+        /* boundaries force it to snap right                               */
+        if ( valid_stems == 1                                  &&
+             advance_stem_location > (advance_width * 2) / 3   &&
+             advance_width == 6 * one_pixel                    &&
+             rightmost_point + modulus - delta
+               <= ( width - (columns_per_pixel * 2) / 3) * 256 &&
+             ppem == 11                                        )
+          *translate_value = ( modulus - delta ) / ( columns_per_pixel * 4 );
+      }
+
+      if ( strategy_use_strengths )
+      {
+        /* consider 1/2 pixel the max when strength is at 100%,
+           unless translate is already greater than that */
+        FT_Int strength_cutoff = 32;
+        if ( abs ( *translate_value ) > strength_cutoff )
+          strength_cutoff = *translate_value;
+
+        max_strength = ( strength_cutoff * alignment_strength ) / 100;
+
+        if ( *translate_value < -max_strength )
+          *translate_value = -max_strength;
+        else if  ( *translate_value > max_strength )
+          *translate_value = max_strength;
+      }
+
+      /* If 2 stems is detected, scale distance
+         between in order to land on pixels */
+      if ( valid_stems >= 2 )
+      {
+        stem_distance = abs ( stems[1].center - stems[0].center );
+
+        delta = stem_distance % modulus;
+        new_distance = stem_distance - delta;
+
+        distance_floor = stem_distance - delta;
+        distance_ceiling = stem_distance + ( modulus - delta );
+
+        if ( delta < modulus / 2 )
+          new_distance = distance_floor;
+        else
+          new_distance = distance_ceiling;
+
+        if ( columns_per_pixel == 3                                    &&
+             valid_stems == 3                                          &&
+             strategy_use_m_control                                    &&
+             ( width - 2 * columns_per_pixel ) > 6 * columns_per_pixel &&
+             ppem > 8                                                  &&
+             ( advance_stem_location - advance_leftmost_location )
+               < stems[main_stem].width * 2                            )
+        {
+          /* Possibly use 2 only when compatible widths is on? */
+          FT_Int mod_factor = 2;
+
+          if ( verbose )
+            printf ( "USING M CONTROL ");
+
+          distance_floor = stem_distance
+                             - stem_distance % ( modulus * mod_factor ) ;
+          distance_ceiling = distance_floor + modulus * mod_factor;
+
+          new_distance = distance_ceiling;
+
+          /* force certain ideal situations */
+          /* these 2 are mostly safe to do */
+          if ( distance_ceiling
+                 + one_pixel * columns_per_pixel == advance_width &&
+               stem_width < one_pixel * 1.25                      )
+            new_distance = distance_ceiling;
+          /* NEED TO FIGURE OUT A WAY TO DETERMINE WHETHER
+             THAT NUDGE IS UP OR DOWN */
+          else if ( stem_distance + one_pixel * 2.6 >= advance_width &&
+            stem_width < one_pixel * 1.25                            )
+            new_distance = distance_ceiling;
+
+          if ( proposed_transformed_point ( leftmost_point )
+                 < one_third_pixel * 2                       ||
+               proposed_transformed_point ( rightmost_point )
+                 > ( width -2 ) * one_third_pixel            )
+            new_distance = distance_floor;
+
+          /* NEED TO IGNORE SERIF Ms HERE */
+          /* perhaps check bitmap boundaries instead??? */
+          if ( strategy_bearing_correction && new_distance == distance_ceiling )
+          {
+            /* Correct if bearings are made substantially worse
+               (more than 1/3 a pixel beyond advance) */
+            if ( proposed_transformed_point( advance_rightmost_location )
+                   > advance_width + one_third_pixel                     &&
+                 proposed_transformed_point( advance_rightmost_location )
+                   > advance_rightmost_location                          &&
+                -proposed_transformed_point( advance_leftmost_location )
+                   < advance_rightmost_location - advance_width          )
+              new_distance = distance_floor;
+          }
+
+          if ( known_stem_values->m >= 0 )
+          {
+            if ( known_stem_values->m == 0 )
+              new_distance = distance_floor;
+            else
+              new_distance = distance_ceiling;
+          }
+
+          if ( ( rightmost_point - leftmost_point) -
+                ( ( rightmost_point * *scale_value)
+                  - ( leftmost_point * *scale_value ) ) >= one_pixel * 1.5 )
+          {
+            *scale_value = 1.0;
+            *translate_value = 0;
+            goto Exit;
+          }
+
+        }
+        else if ( columns_per_pixel == 1                                &&
+                  valid_stems == 3 &&
+                  strategy_use_m_control && valid_stems == 3            &&
+                  width >= 6 * columns_per_pixel                        &&
+                  ppem > 8                                              &&
+                  ( advance_stem_location - advance_leftmost_location )
+                    < stems[main_stem].width * 2                        )
+        {
+          /* Possibly use 2 only when compatible widths is on? */
+          FT_Int mod_factor = 2;
+
+          if ( verbose )
+            printf ("USING M CONTROL ");
+          distance_floor = stem_distance - stem_distance
+                                             % ( modulus * mod_factor) ;
+          distance_ceiling = distance_floor + modulus * mod_factor;
+
+          new_distance = distance_ceiling;
+
+          /* force certain ideal situations */
+          /* these 2 are mostly safe to do */
+          if ( distance_ceiling
+                 + one_pixel * columns_per_pixel == advance_width &&
+               stem_width < one_pixel * 1.25                      )
+            new_distance = distance_ceiling;
+          /* NEED TO FIGURE OUT A WAY TO DETERMINE WHETHER
+            THAT NUDGE IS UP OR DOWN */
+          else if ( stem_distance + one_pixel * 2.6 >= advance_width &&
+                    stem_width < one_pixel * 1.25                    )
+            new_distance = distance_ceiling;
+
+          if ( proposed_transformed_point( leftmost_point ) < 0 ||
+               proposed_transformed_point( rightmost_point )
+                 > width * one_pixel - 2 * one_third_pixel      )
+            new_distance = distance_floor;
+
+          /* NEED TO IGNORE SERIF Ms HERE */
+          /* perhaps check bitmap boundaries instead??? */
+          if ( strategy_bearing_correction && new_distance == distance_ceiling )
+          {
+            /* Correct if bearings are made substantially worse
+               (more than 1/3 a pixel beyond advance) */
+            if ( proposed_transformed_point( advance_rightmost_location )
+                   > advance_width + one_third_pixel                      &&
+                proposed_transformed_point( advance_rightmost_location )
+                   > advance_rightmost_location                           &&
+                -proposed_transformed_point( advance_leftmost_location )
+                   < advance_rightmost_location - advance_width           )
+              new_distance = distance_floor;
+          }
+
+          if ( known_stem_values->m >= 0 )
+          {
+            if ( known_stem_values->m == 0 )
+              new_distance = distance_floor;
+            else
+              new_distance = distance_ceiling;
+          }
+
+
+          if ( ( rightmost_point - leftmost_point )
+                 - ( ( rightmost_point * *scale_value )
+                      - ( leftmost_point * *scale_value ) ) >= one_pixel * 1.5 )
+          {
+            *scale_value = 1.0;
+            *translate_value = 0;
+            goto Exit;
+          }
+
+        }
+        else
+        {
+          if ( strategy_fit_to_width )
+            new_distance = advance_width - 3 * one_pixel;
+          else if ( known_stem_values->stem_scaling >= 0 )
+          {
+            if ( known_stem_values->stem_scaling > 0 )
+              new_distance = distance_ceiling;
+            else
+              new_distance = distance_floor;
+
+            /* enforce advance width boundaries */
+            /* TOO RESTRICTIVE ON SERIF FONTS */
+            if ( proposed_transformed_point( advance_rightmost_location )
+                   >= advance_width                                      ||
+                 proposed_transformed_point( advance_leftmost_location )
+                   <= 0                                                  )
+              new_distance = distance_floor;
+
+            /* enforce literal bitmap boundaries if no translate room */
+            if ( ( proposed_transformed_point(rightmost_point) >= width * 256
+                || proposed_transformed_point(leftmost_point ) <= one_pixel )
+              && new_distance + one_pixel * 3 > advance_width )
+              new_distance = distance_floor;
+
+          }
+          else if ( strategy_translate_using_closest_stem )
+          {
+            /* closest snapping point for stem 1 */
+            delta2 = ( stems[1].center  + center_offset ) % modulus;
+
+            if ( delta2 < modulus / 2 )
+              /* snap left */
+              translate_value2 = -delta2 / ( columns_per_pixel * 4 );
+            else
+               /* snap right */
+              translate_value2 = ( modulus - delta2 )
+                                     / ( columns_per_pixel * 4 );
+
+            if ( abs ( translate_value2 ) < abs ( *translate_value ) )
+            {
+              *translate_value = translate_value2;
+              main_stem = 1;
+            }
+
+          }
+          else if ( strategy_scale_to_closest_centers )
+          {
+            /* closest snapping point for stem 0 */
+            delta  = ( stems[0].center + center_offset ) % modulus;
+            delta2 = ( stems[1].center + center_offset ) % modulus;
+
+            if ( delta < modulus / 2 )
+              /* stretch left */
+              new_distance = delta + stem_distance;
+            else
+              /* stretch right */
+              new_distance = delta - modulus + stem_distance;
+
+            if ( delta2 < modulus / 2 )
+              new_distance -= delta2;  /* stretch left */
+            else
+              new_distance += modulus - delta2; /* stretch right */
+
+          }
+          else if ( strategy_scale_to_closest_centers_up_only )
+          {
+            FT_Int net_change = 0;
+
+            /* closest snapping point for stem 0 */
+            delta  = ( stems[0].center + center_offset ) % modulus;
+            delta2 = ( stems[1].center + center_offset ) % modulus;
+
+            if ( delta < modulus / 2 )
+              net_change = delta;  /* stretch left */
+            else
+              net_change = -( modulus - delta );      /* stretch right */
+
+            if ( delta2 < modulus / 2 )
+              net_change -= delta2;  /* stretch left */
+            else
+              net_change += modulus - delta2;      /* stretch right */
+
+            if ( net_change > 0                                              &&
+                 proposed_transformed_point( advance_rightmost_location )
+                   < advance_width                                           &&
+                 proposed_transformed_point( advance_leftmost_location ) > 0 )
+              new_distance = distance_ceiling;
+          }
+
+          else if ( strategy_always_use_distance_ceiling )
+          {
+            if ( proposed_transformed_point( advance_rightmost_location )
+                   < advance_width                                           &&
+                 proposed_transformed_point( advance_leftmost_location ) > 0 )
+            new_distance = distance_ceiling;
+          }
+        }
+
+        if ( strategy_use_strengths )
+        {
+          FT_Int strength_cutoff = center_offset;
+
+
+          delta2 = new_distance - stem_distance;
+
+          if ( abs ( delta2 ) > strength_cutoff )
+            strength_cutoff = delta2;
+
+          max_strength = ( strength_cutoff * fitting_strength ) / 100;
+
+          if ( delta2 < -max_strength )
+            new_distance = stem_distance - max_strength;
+          else if ( delta2 > max_strength )
+            new_distance = stem_distance + max_strength;
+        }
+
+        *scale_value = (float)( new_distance ) / (float)( stem_distance );
+        *translate_value = *translate_value
+           - ( (float)( stems[main_stem].center * (float)new_distance )
+                      / (float)stem_distance - stems[main_stem].center ) / 12;
+
+        if ( valid_stems == 2 )
+          *embolden_value = ( 64.0 / *scale_value - 64.0 );
+
+        if ( valid_stems == 3 )
+          *embolden_value = ( 64.0 / *scale_value - 64.0 ) / 1.5;
+      }
+
+      if ( verbose )
+        printf ( "%lu stems:", valid_stems );
+
+      if ( valid_stems == 1 && verbose )
+        printf ( "1 stem:    bitmapwidth:%d glyphwidth:%f glyph_width:%f center:%f bearing:%f advance:%f lhadvance:%f stemwidth:%f %d %d",
+                (width - 6) / columns_per_pixel,
+                (float)m_width / 64.0,
+                (float)glyph_width / (float)one_pixel,
+                (float)( (float)advance_stem_location ) / (float)one_pixel,
+                (float)m_horiBearingX / 64.0,
+                (float)m_horiAdvance / 64.0,
+                (float)linearHoriAdvance / 64.0,
+                (float)stems[0].width / (float)one_pixel,
+                advance_width, original_advance_width );
+      else if ( valid_stems >= 2 && verbose )
+        printf ( "%lu stems: bitmapwidth:%d center1:%f center2:%f difference:%f bearing:%f advance:%f advstemloc:%f ",
+                valid_stems,
+                (width - 6) / columns_per_pixel,
+                ( (float)advance_stem_location ) / (float)one_pixel,
+                ( (float)advance_stem_location
+                    + (float)abs ( stems[1].center
+                                     - stems[0].center) ) / (float)one_pixel,
+                ( (float)abs ( stems[1].center
+                                 - stems[0].center ) ) / (float)one_pixel,
+                (float)m_horiBearingX / 64.0,
+                (float)m_horiAdvance / 64.0,
+                (float)advance_stem_location / (float)one_pixel );
+
+      if ( strategy_bearing_correction )
+      {
+        /* Correct if negative bearings are made substantially worse */
+        /* (more than 1/3 a pixel)                                   */
+        if ( proposed_transformed_point( advance_rightmost_location )
+               > advance_width                                       &&
+             proposed_transformed_point( advance_rightmost_location )
+               > advance_rightmost_location                          &&
+             -proposed_transformed_point( advance_leftmost_location )
+               < advance_rightmost_location - advance_width          &&
+             *translate_value
+               > one_third_pixel / ( columns_per_pixel * 4 )         )
+        {
+          *translate_value -=64 ;
+          if ( verbose )
+            printf ( "TRANSLATING -64 " );
+        }
+      }
+      goto Exit;
+    }
+
+  Exit:
+
+#define transformed_point( point ) point * *scale_value + *translate_value * 12
+
+    if ( strategy_correct_out_of_bounds_outlines )
+    {
+      /* Correct if outside bitmap */
+      if ( transformed_point( rightmost_point )
+             >= width * 256 - 2 * one_third_pixel &&
+           transformed_point( leftmost_point )
+             > one_pixel + 2 * one_third_pixel    )
+        *translate_value -=64 ;
+      else if ( transformed_point( leftmost_point )
+                  <= one_pixel / 2                                &&
+                transformed_point( rightmost_point )
+                  <= width * 256 - ( one_pixel +  one_pixel / 2 ) )
+        *translate_value += 64;
+    }
+
+    STVALUES
+    free ( centers );
+    free ( segments );
+    free ( stem_centers );
+    free ( stems );
+    free ( leftmost_segment );
+  }
+
+
+  /* Gamma correction */
+  static void
+  _ft_lcd_gamma_correction_correction ( FT_Bitmap*      bitmap,
+                                        FT_Render_Mode  mode,
+                                        FT_GlyphSlot    slot,
+                                        float           gamma_correction_lt,
+                                        float           gamma_correction_value )
+  {
+    if ( gamma_correction_value != 1.0 )
+    {
+      FT_UInt   width  = (FT_UInt)bitmap->width;
+      FT_UInt   height = (FT_UInt)bitmap->rows;
+      FT_Byte*  line   = bitmap->buffer;
+      float     ppem   = (float)slot->face->size->metrics.x_ppem;
+
+
+      if ( !slot->face || !slot->face->size ) return;
+
+      if ( ppem >= 5 )
+        for ( height = (FT_UInt)bitmap->rows;
+              height > 0;
+              height--, line += bitmap->pitch )
+        {
+          FT_UInt  xx;
+
+
+          for ( xx = 0; xx < width; xx += 1 )
+          {
+            /*normal*/
+            /*line[xx] = pseudo_gamma ( line[xx], gamma_correction_value );*/
+
+            /* sloped */
+            /*line[xx] = pseudo_gamma ( line[xx], gamma_correction_value - 5
+            * (1-gamma_correction_value)/(gamma_correction_lt -5)
+            + ((1-gamma_correction_value)/(gamma_correction_lt -5)) * ppem );*/
+
+            /* 1/3-sloped */
+            line[xx] = pseudo_gamma ( line[xx], gamma_correction_value - 5
+            * ( ( 1 - gamma_correction_value )
+                / ( 3 * ( gamma_correction_lt -5 ) ) )
+            + ( ( 1 - gamma_correction_value )
+                / ( 3 * ( gamma_correction_lt -5) ) ) * ppem );
+          }
+        }
+    }
+  }
+
+#endif
 
   /* convert a slot's glyph image into a bitmap */
   static FT_Error
@@ -103,24 +2328,162 @@
                             FT_Render_Mode    required_mode )
   {
     FT_Error     error;
-    FT_Outline*  outline = &slot->outline;
-    FT_Bitmap*   bitmap  = &slot->bitmap;
-    FT_Memory    memory  = render->root.memory;
+    FT_Outline*  outline = NULL;
+    FT_Outline*  outline_orig = NULL;
     FT_BBox      cbox;
-    FT_Pos       x_shift = 0;
-    FT_Pos       y_shift = 0;
-    FT_Pos       x_left, y_top;
-    FT_Pos       width, height, pitch;
+    FT_Pos       width, height, pitch, ppem;
 #ifndef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
     FT_Pos       height_org, width_org;
 #endif
+    FT_Bitmap*   bitmap  = &slot->bitmap;
+    FT_Memory    memory  = render->root.memory;
     FT_Int       hmul    = ( mode == FT_RENDER_MODE_LCD );
     FT_Int       vmul    = ( mode == FT_RENDER_MODE_LCD_V );
+    FT_Pos       x_shift = 0;
+    FT_Pos       y_shift = 0;
+    FT_Pos       x_left, y_top;
 
     FT_Raster_Params  params;
 
-    FT_Bool  have_outline_shifted = FALSE;
-    FT_Bool  have_buffer          = FALSE;
+    FT_Bool  have_translated_origin = FALSE;
+    FT_Bool  have_outline_shifted   = FALSE;
+    FT_Bool  have_buffer            = FALSE;
+
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    FT_Matrix    scaleMat;
+    FT_Long      translate_value = 0;
+    float        scale_value = 1.0;
+    FT_Int       align_called = 0;
+
+
+    int          chromeos_style_sharpening_strength = 0;
+    int          alignment_strength = 0;
+    int          fitting_strength = 0;
+    int          fringe_filter_strength = 0;
+    int          grayscale_filter_strength = 0;
+
+    int          autohint_horizontal_stem_darken_strength = 0;
+    int          autohint_vertical_stem_darken_strength = 0;
+
+    int          windows_style_sharpening_strength = 0;
+    float        gamma_correction_value = 1;
+    float        gamma_correction_lt = 0;
+
+    FT_Int       brightness_value = 0.0;
+    FT_Int       contrast_value = 0.0;
+
+    FT_Int       snapping_sliding_scale_value = 0;
+
+    FT_Int       global_embolden_x_value = 0;
+    FT_Int       global_embolden_y_value = 0;
+
+    FT_Int       bold_embolden_x_value = 0;
+    FT_Int       bold_embolden_y_value = 0;
+
+    FT_Byte      chromeos_cutoff;
+    double       chromeos_gamma_value;
+
+    float        embolden_value = 0.0;
+    FT_Bool      autohinted = FALSE;
+    FT_Bool      use_various_tweaks = FALSE;
+    FT_Pos       cur_width = infinality_cur_width;
+
+    const FT_Int MIN_PPEM = 1;
+    /*const FT_Int    MAX_PPEM = 100;    */
+
+    FT_Bool use_known_settings_on_selected_fonts;
+
+    if ( slot->face                       &&
+         slot->face->size                 &&
+         slot->face->size->metrics.x_ppem )
+      ppem = slot->face->size->metrics.x_ppem;
+    else
+      ppem = 0;
+
+    if ( cur_width )
+    {
+        autohinted = TRUE;
+    }
+    if( ftinf ){
+        const float *f=ftinf->gamma_correction;
+
+        use_known_settings_on_selected_fonts=ftinf->use_known_settings_on_selected_fonts;
+        use_various_tweaks=ftinf->use_various_tweaks;
+        snapping_sliding_scale_value=ftinf->stem_snapping_sliding_scale;
+
+        alignment_strength=ftinf->stem_alignment_strength;
+        if ( snapping_sliding_scale_value != 0 )
+            alignment_strength = sliding_scale(10, snapping_sliding_scale_value, alignment_strength, 100, ppem);
+
+        fitting_strength=ftinf->stem_fitting_strength;
+        if ( snapping_sliding_scale_value != 0 )
+            fitting_strength = sliding_scale(10, snapping_sliding_scale_value, fitting_strength, 100, ppem);
+
+        chromeos_style_sharpening_strength=ftinf->chromeos_style_sharpening_strength;
+
+        if ( ppem > 10 )
+            chromeos_style_sharpening_strength =
+                ( chromeos_style_sharpening_strength * ppem ) / 10;
+
+        if ( chromeos_style_sharpening_strength > 100 )
+            chromeos_style_sharpening_strength = 100;
+
+        brightness_value=ftinf->brightness;
+        contrast_value=ftinf->contrast;
+
+        windows_style_sharpening_strength=ftinf->windows_style_sharpening_strength;
+
+        /* Decrease effect slightly to have a more linear increase in sharpness */
+        windows_style_sharpening_strength =
+            ( ( windows_style_sharpening_strength
+                * windows_style_sharpening_strength ) / 100
+              + windows_style_sharpening_strength ) / 2;
+
+        gamma_correction_lt = f[0];
+        gamma_correction_value = f[1] / 100.0f;
+
+        fringe_filter_strength=ftinf->fringe_filter_strength;
+        grayscale_filter_strength=ftinf->grayscale_filter_strength;
+
+        autohint_horizontal_stem_darken_strength=ftinf->autohint_horizontal_stem_darken_strength;
+        autohint_vertical_stem_darken_strength=ftinf->autohint_vertical_stem_darken_strength;
+
+        global_embolden_x_value=ftinf->global_embolden_x_value;
+        global_embolden_y_value=ftinf->global_embolden_y_value;
+
+        bold_embolden_x_value=ftinf->bold_embolden_x_value;
+        bold_embolden_y_value=ftinf->bold_embolden_y_value;
+    } else {
+        use_known_settings_on_selected_fonts=FALSE;
+    }
+
+    /* set gamma value to 1 if out of range */
+    if ( slot->face                       &&
+         slot->face->size                 &&
+         slot->face->size->metrics.x_ppem )
+    {
+      if ( slot->face->size->metrics.x_ppem >= gamma_correction_lt )
+        gamma_correction_value = 1;
+    }
+    else
+      gamma_correction_value = 1;
+
+    if( use_various_tweaks     &&
+        slot->face             &&
+        slot->face->style_name )
+    {
+      /* needs to also check for artifical italics */
+      if ( stricmp(slot->face->style_name, "Italic" )  ||
+           stricmp(slot->face->style_name, "Oblique" ) )
+      {
+        windows_style_sharpening_strength = 0;
+        chromeos_style_sharpening_strength = 0;
+      }
+    }
+
+    /*if (fitting_strength == 100) scale_value = 1.1;*/
+
+#endif
 
 #ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
 
@@ -191,26 +2554,119 @@
       goto Exit;
     }
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+RERENDER:
+    if ( align_called == 1 )
+    {
+      scaleMat.xx = FT_FixedFromFloat(scale_value);
+      scaleMat.xy = 0;
+      scaleMat.yx = 0;
+      scaleMat.yy = ( 1 << 16 );
+
+      FT_Outline_Copy(outline_orig, outline);
+
+      if ( scale_value != 1.0 )
+        FT_Outline_Transform( outline, &scaleMat );
+
+      FT_Outline_Translate( outline, translate_value, 0 );
+
+      FT_Outline_EmboldenXY( outline, embolden_value, 0 );
+    }
+    else
+    {
+#endif
+    outline = &slot->outline;
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+      /* Need to get this PRIOR to embolden, otherwise bad things happen */
+      FT_Outline_Get_CBox( outline, &cbox );
+
+      /* Various hacks that need to be turned into a new rule set */
+      /*if ( !autohinted
+        && use_known_settings_on_selected_fonts
+        && mode == FT_RENDER_MODE_LCD
+        && slot->face->family_name
+        && slot->face->style_name
+        && ( stricmp(slot->face->family_name, "Courier New" )
+          && ( stricmp(slot->face->style_name, "Regular" )
+            || stricmp(slot->face->style_name, "Italic" ) ) ) )
+        FT_Outline_Embolden( outline, 24 );*/
+
+      if ( slot->face )
+      {
+        if ( !autohinted                                              &&
+            use_known_settings_on_selected_fonts                     &&
+            mode == FT_RENDER_MODE_LCD                               &&
+            slot->face->family_name                                  &&
+            slot->face->style_name                                   &&
+            stricmp( slot->face->family_name, "Times New Roman" ) &&
+            stricmp( slot->face->style_name, "Italic" )           )
+          FT_Outline_EmboldenXY( outline, 12, 0 );
+
+        if ( use_known_settings_on_selected_fonts              &&
+            autohinted                                        &&
+            mode == FT_RENDER_MODE_LCD                        &&
+            slot->face->family_name                           &&
+            slot->face->style_name                            &&
+            stricmp(slot->face->family_name, "FreeSerif" ) &&
+            stricmp(slot->face->style_name, "Italic" )     )
+          FT_Outline_EmboldenXY( outline, 8, 0 );
+
+        if ( global_embolden_x_value != 0 || global_embolden_y_value != 0 )
+              FT_Outline_EmboldenXY( outline,
+                                    global_embolden_x_value,
+                                    global_embolden_y_value );
+
+        if ( ( bold_embolden_x_value != 0 || bold_embolden_y_value != 0 ) &&
+            ( slot->face->style_name                             &&
+            ( stricmp(slot->face->style_name, "Bold" ) ||
+              stricmp(slot->face->style_name, "Black"  )    ||
+              ( slot->face->style_flags                      &&
+                slot->face->style_flags & FT_STYLE_FLAG_BOLD ) ) )       )
+          FT_Outline_EmboldenXY( outline,
+                                  bold_embolden_x_value,
+                                  bold_embolden_y_value );
+      }
+
+      FT_Outline_Copy( outline, outline_orig );
+    }
+
+    /* translate the outline to the new origin if needed */
+    if ( align_called == 0 )
+    {
+      FT_Pos enlarge_cbox = 0;
+
+      /* enlarge for grayscale rendering */
+      if ( mode == FT_RENDER_MODE_NORMAL )
+        enlarge_cbox = 64;
+
+      if ( origin )
+      {
+        FT_Outline_Translate( outline, origin->x, origin->y );
+        have_translated_origin = TRUE;
+      }
+
+      /* compute the control box, and grid fit it */
+      /*FT_Outline_Get_CBox( outline, &cbox );*/
+
+      cbox.xMin = FT_PIX_FLOOR( cbox.xMin - enlarge_cbox );
+      cbox.yMin = FT_PIX_FLOOR( cbox.yMin );
+      cbox.xMax = FT_PIX_CEIL( cbox.xMax + enlarge_cbox );
+      cbox.yMax = FT_PIX_CEIL( cbox.yMax );
+#else
     if ( origin )
     {
-      x_shift = origin->x;
-      y_shift = origin->y;
+      FT_Outline_Translate( outline, origin->x, origin->y );
+      have_translated_origin = TRUE;
     }
 
     /* compute the control box, and grid fit it */
-    /* taking into account the origin shift     */
     FT_Outline_Get_CBox( outline, &cbox );
 
-    cbox.xMin = FT_PIX_FLOOR( cbox.xMin + x_shift );
-    cbox.yMin = FT_PIX_FLOOR( cbox.yMin + y_shift );
-    cbox.xMax = FT_PIX_CEIL( cbox.xMax + x_shift );
-    cbox.yMax = FT_PIX_CEIL( cbox.yMax + y_shift );
-
-    x_shift -= cbox.xMin;
-    y_shift -= cbox.yMin;
-
-    x_left  = cbox.xMin >> 6;
-    y_top   = cbox.yMax >> 6;
+    cbox.xMin = FT_PIX_FLOOR( cbox.xMin );
+    cbox.yMin = FT_PIX_FLOOR( cbox.yMin );
+    cbox.xMax = FT_PIX_CEIL( cbox.xMax );
+    cbox.yMax = FT_PIX_CEIL( cbox.yMax );
+#endif
 
     width  = (FT_ULong)( cbox.xMax - cbox.xMin ) >> 6;
     height = (FT_ULong)( cbox.yMax - cbox.yMin ) >> 6;
@@ -220,22 +2676,35 @@
     height_org = height;
 #endif
 
+    /* release old bitmap buffer */
+    if ( slot->internal->flags & FT_GLYPH_OWN_BITMAP )
+    {
+      FT_FREE( bitmap->buffer );
+      slot->internal->flags &= ~FT_GLYPH_OWN_BITMAP;
+    }
+
+    /* allocate new one */
     pitch = width;
     if ( hmul )
     {
-      width *= 3;
-      pitch  = FT_PAD_CEIL( width, 4 );
+      width = width * 3;
+      pitch = FT_PAD_CEIL( width, 4 );
     }
 
     if ( vmul )
       height *= 3;
 
+    x_shift = cbox.xMin;
+    y_shift = cbox.yMin;
+    x_left  = cbox.xMin >> 6;
+    y_top   = cbox.yMax >> 6;
+
 #ifdef FT_CONFIG_OPTION_SUBPIXEL_RENDERING
     if ( lcd_filter_func )
     {
       if ( hmul )
       {
-        x_shift += 64 * ( lcd_extra >> 1 );
+        x_shift -= 64 * ( lcd_extra >> 1 );
         x_left  -= lcd_extra >> 1;
         width   += 3 * lcd_extra;
         pitch    = FT_PAD_CEIL( width, 4 );
@@ -243,23 +2712,16 @@
 
       if ( vmul )
       {
-        y_shift += 64 * ( lcd_extra >> 1 );
+        y_shift -= 64 * ( lcd_extra >> 1 );
         y_top   += lcd_extra >> 1;
         height  += 3 * lcd_extra;
       }
     }
 #endif
-
-    /*
-     * XXX: on 16bit system, we return an error for huge bitmap
-     * to prevent an overflow.
-     */
-    if ( x_left > FT_INT_MAX || y_top > FT_INT_MAX ||
-         x_left < FT_INT_MIN || y_top < FT_INT_MIN )
-    {
-      error = FT_THROW( Invalid_Pixel_Size );
-      goto Exit;
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
     }
+#endif
+
 
     /* Required check is (pitch * height < FT_ULONG_MAX),        */
     /* but we care realistic cases only.  Always pitch <= width. */
@@ -271,6 +2733,22 @@
       goto Exit;
     }
 
+    bitmap->pixel_mode = FT_PIXEL_MODE_GRAY;
+    bitmap->num_grays  = 256;
+    bitmap->width      = (unsigned int)width;
+    bitmap->rows       = (unsigned int)height;
+    bitmap->pitch      = pitch;
+
+    /* translate outline to render it into the bitmap */
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    if ( align_called == 0 )
+    {
+#endif
+    FT_Outline_Translate( outline, -x_shift, -y_shift );
+    have_outline_shifted = TRUE;
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    }
+#endif
     /* release old bitmap buffer */
     if ( slot->internal->flags & FT_GLYPH_OWN_BITMAP )
     {
@@ -278,7 +2756,6 @@
       slot->internal->flags &= ~FT_GLYPH_OWN_BITMAP;
     }
 
-    /* allocate new one */
     if ( FT_ALLOC( bitmap->buffer, (FT_ULong)( pitch * height ) ) )
       goto Exit;
     else
@@ -286,23 +2763,6 @@
 
     slot->internal->flags |= FT_GLYPH_OWN_BITMAP;
 
-    slot->format      = FT_GLYPH_FORMAT_BITMAP;
-    slot->bitmap_left = (FT_Int)x_left;
-    slot->bitmap_top  = (FT_Int)y_top;
-
-    bitmap->pixel_mode = FT_PIXEL_MODE_GRAY;
-    bitmap->num_grays  = 256;
-    bitmap->width      = (unsigned int)width;
-    bitmap->rows       = (unsigned int)height;
-    bitmap->pitch      = pitch;
-
-    /* translate outline to render it into the bitmap */
-    if ( x_shift || y_shift )
-    {
-      FT_Outline_Translate( outline, x_shift, y_shift );
-      have_outline_shifted = TRUE;
-    }
-
     /* set up parameters */
     params.target = bitmap;
     params.source = outline;
@@ -348,8 +2808,152 @@
     if ( error )
       goto Exit;
 
+#ifdef FT_CONFIG_OPTION_INFINALITY_PATCHSET
+    if ( ppem <= MAX_PPEM && ppem >= MIN_PPEM )
+    {
+      if ( align_called == 0                                  &&  cur_width / ppem < 10 &&
+           ( alignment_strength > 0 || fitting_strength > 0 ) )
+        _lcd_stem_align ( bitmap,
+                          mode,
+                          slot,
+                          &translate_value,
+                          &scale_value,
+                          alignment_strength,
+                          fitting_strength,
+                          &embolden_value );
+
+      if ( align_called == 0                              &&
+           ( translate_value != 0 || scale_value != 1.0 ) )
+      {
+        align_called = 1;
+        goto RERENDER;
+      }
+
+      if ( mode == FT_RENDER_MODE_LCD )
+      {
+
+        if ( fringe_filter_strength > 0 /*&& autohinted*/ )
+          _ft_lcd_fringe_filter( bitmap,
+                                 mode,
+                                 fringe_filter_strength,
+                                 slot->library );
+
+        /*if ( autohinted)
+          _ft_lcd_stem_end_filter( bitmap, mode, 100, slot->library );*/
+
+        if ( gamma_correction_lt > 0 && gamma_correction_value != 1.0 )
+          _ft_lcd_gamma_correction_correction( bitmap,
+                                               mode,
+                                               slot,
+                                               gamma_correction_lt,
+                                               gamma_correction_value );
+
+        chromeos_cutoff = (FT_Byte)( 0.5 * 255.0 )
+                            * ( chromeos_style_sharpening_strength / 100.0 );
+        chromeos_gamma_value = 1;
+
+        if ( chromeos_style_sharpening_strength > 0 )
+          _ft_lcd_chromeos_sharpen( bitmap,
+                                    mode,
+                                    chromeos_cutoff,
+                                    chromeos_gamma_value );
+
+        if ( ppem > 8 )
+          if ( windows_style_sharpening_strength > 0 )
+            _ft_lcd_windows_sharpen( bitmap,
+                                     mode,
+                                     windows_style_sharpening_strength,
+                                     slot->library );
+
+        if ( autohinted                                    &&
+             ( cur_width * 100 ) / 64
+               > autohint_horizontal_stem_darken_strength  &&
+             autohint_horizontal_stem_darken_strength != 0 )
+          autohint_horizontal_stem_darken_strength = ( cur_width * 100 ) / 64;
+
+        if ( autohint_horizontal_stem_darken_strength > 100)
+          autohint_horizontal_stem_darken_strength = 100;
+
+        /* only do on autohinted fonts */
+        /* Necessary to do on some non-thin fonts, which is why it is outside */
+        /* of the below conditional */
+        if ( autohint_horizontal_stem_darken_strength > 0 && autohinted )
+          _ft_lcd_darken_x ( bitmap,
+                             mode,
+                             autohint_horizontal_stem_darken_strength,
+                             slot->library );
+
+        /* Enhance thin fonts */
+        if ( autohinted )
+        {
+          /* if forcibly set use that, otherwise make a good estimate */
+          float contrast, brightness;
+          ftinf_get_bc( slot->face->family_name, ppem, &brightness, &contrast);
+          if ( slot->face && !_ft_bitmap_bc ( bitmap, brightness, contrast ) )
+          {
+            FT_Bool is_fixed_name = FALSE;
+
+            if ( slot->face->family_name                      &&
+				stricmp(slot->face->family_name, "Mono" ) )
+              is_fixed_name = TRUE;
+
+            /* Darken vertical stems */
+            _ft_lcd_darken_y ( bitmap,
+                               mode,
+                               autohint_vertical_stem_darken_strength,
+                               slot->library );
+
+            /* Adjust brightness / contrast automatically based on stem width */
+            if ( cur_width != 0 && cur_width < 30 )
+              cur_width = 30;
+
+            if ( cur_width >= 30 && cur_width <= 60 )
+            {
+              float ppem_factor       = sliding_scale ( 5, 11, 0.0, 1.0, ppem );
+              float brightness_factor = sliding_scale ( 30, 52, -.3, 0.0,
+                                                        cur_width );
+              float contrast_factor   = sliding_scale ( 30, 52, .45, 0.0,
+                                                        cur_width );
+              _ft_bitmap_bc ( bitmap,
+                              ppem_factor * brightness_factor,
+                              ppem_factor * contrast_factor );
+
+              /* Only cap variable width thin-stemmed fonts */
+              if ( !FT_IS_FIXED_WIDTH( slot->face ) && !is_fixed_name )
+                _ft_bitmap_cap ( bitmap,
+                                 ( cur_width * 150 ) / 64,
+                                 slot->library );
+            }
+          }
+        }
+
+
+        if ( lcd_filter_func )
+          lcd_filter_func( bitmap, mode, lcd_weights );
+
+        if ( grayscale_filter_strength > 0 )
+          _ft_lcd_grayscale_filter( bitmap,
+                                    mode,
+                                    grayscale_filter_strength,
+                                    slot->library );
+
+      }
+
+      /* Global values */
+      if ( brightness_value != 0 || contrast_value != 0 )
+        _ft_bitmap_bc ( bitmap,
+                        (float)brightness_value / 300.0,
+                        (float)contrast_value / 300.0);
+
+      FT_Outline_Done( slot->library, outline_orig );
+    }
+    else if ( mode == FT_RENDER_MODE_LCD     &&
+              lcd_filter_func )
+          lcd_filter_func( bitmap, mode, lcd_weights );
+#else
     if ( lcd_filter_func )
       lcd_filter_func( bitmap, mode, lcd_weights );
+#endif /* FT_CONFIG_OPTION_INFINALITY_PATCHSET */
 
 #else /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
 
@@ -408,6 +3012,20 @@
 
 #endif /* !FT_CONFIG_OPTION_SUBPIXEL_RENDERING */
 
+    /*
+     * XXX: on 16bit system, we return an error for huge bitmap
+     * to prevent an overflow.
+     */
+    if ( x_left > FT_INT_MAX || y_top > FT_INT_MAX )
+    {
+      error = FT_THROW( Invalid_Pixel_Size );
+      goto Exit;
+    }
+
+    slot->format      = FT_GLYPH_FORMAT_BITMAP;
+    slot->bitmap_left = (FT_Int)x_left;
+    slot->bitmap_top  = (FT_Int)y_top;
+
     /* everything is fine; don't deallocate buffer */
     have_buffer = FALSE;
 
@@ -415,7 +3033,9 @@
 
   Exit:
     if ( have_outline_shifted )
-      FT_Outline_Translate( outline, -x_shift, -y_shift );
+      FT_Outline_Translate( outline, x_shift, y_shift );
+    if ( have_translated_origin )
+      FT_Outline_Translate( outline, -origin->x, -origin->y );
     if ( have_buffer )
     {
       FT_FREE( bitmap->buffer );
diff -Nur freetype-2.8/src/tools/ftrandom/ftrandom.c freetype-2.8.compiles-with-mactype/src/tools/ftrandom/ftrandom.c
--- freetype-2.8/src/tools/ftrandom/ftrandom.c	2017-03-30 05:20:23.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/src/tools/ftrandom/ftrandom.c	2017-10-11 20:53:28.696654600 -0500
@@ -256,8 +256,8 @@
       return false;
 
     for ( i = 0; extensions[i] != NULL; i++ )
-      if ( strcasecmp( pt + 1, extensions[i] ) == 0 ||
-           strcasecmp( pt,     extensions[i] ) == 0 )
+      if ( _stricmp( pt + 1, extensions[i] ) == 0 ||
+           _stricmp( pt,     extensions[i] ) == 0 )
         return true;
 
     return false;
diff -Nur freetype-2.8/src/tools/ftrandom/ftrandom.c.bak freetype-2.8.compiles-with-mactype/src/tools/ftrandom/ftrandom.c.bak
--- freetype-2.8/src/tools/ftrandom/ftrandom.c.bak	1969-12-31 18:00:00.000000000 -0600
+++ freetype-2.8.compiles-with-mactype/src/tools/ftrandom/ftrandom.c.bak	2017-03-30 05:20:23.000000000 -0500
@@ -0,0 +1,720 @@
+/* Copyright (C) 2005, 2007, 2008, 2013 by George Williams */
+/*
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+
+ * Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+
+ * Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+
+ * The name of the author may not be used to endorse or promote products
+ * derived from this software without specific prior written permission.
+
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
+ * EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
+ * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
+ * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/* modified by Werner Lemberg <wl@gnu.org>       */
+/* This file is now part of the FreeType library */
+
+
+#define _XOPEN_SOURCE 500 /* for `kill', `strdup', `random', and `srandom' */
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <strings.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/wait.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <signal.h>
+#include <time.h>
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#include FT_OUTLINE_H
+
+#define true     1
+#define false    0
+#define forever  for (;;)
+
+
+  static int    check_outlines = false;
+  static int    nohints        = false;
+  static int    rasterize      = false;
+  static char*  results_dir    = "results";
+
+#define GOOD_FONTS_DIR  "/usr/local/share/fonts"
+
+  static char*  default_dir_list[] =
+  {
+    GOOD_FONTS_DIR,
+    NULL
+  };
+
+  static char*  default_ext_list[] =
+  {
+    "ttf",
+    "otf",
+    "ttc",
+    "cid",
+    "pfb",
+    "pfa",
+    "bdf",
+    "pcf",
+    "pfr",
+    "fon",
+    "otb",
+    "cff",
+    NULL
+  };
+
+  static unsigned int  error_count    = 1;
+  static double        error_fraction = 0.0;
+
+  static FT_F26Dot6  font_size = 12 * 64;
+
+  static struct fontlist
+  {
+    char*         name;
+    long          len;
+    unsigned int  isbinary: 1;
+    unsigned int  isascii: 1;
+    unsigned int  ishex: 1;
+
+  } *fontlist;
+
+  static unsigned int  fcnt;
+
+
+  static int
+  FT_MoveTo( const FT_Vector  *to,
+             void             *user )
+  {
+    FT_UNUSED( to );
+    FT_UNUSED( user );
+
+    return 0;
+  }
+
+
+  static int
+  FT_LineTo( const FT_Vector  *to,
+             void             *user )
+  {
+    FT_UNUSED( to );
+    FT_UNUSED( user );
+
+    return 0;
+  }
+
+
+  static int
+  FT_ConicTo( const FT_Vector  *_cp,
+              const FT_Vector  *to,
+              void             *user )
+  {
+    FT_UNUSED( _cp );
+    FT_UNUSED( to );
+    FT_UNUSED( user );
+
+    return 0;
+  }
+
+
+  static int
+  FT_CubicTo( const FT_Vector  *cp1,
+              const FT_Vector  *cp2,
+              const FT_Vector  *to,
+              void             *user )
+  {
+    FT_UNUSED( cp1 );
+    FT_UNUSED( cp2 );
+    FT_UNUSED( to );
+    FT_UNUSED( user );
+
+    return 0;
+  }
+
+
+  static FT_Outline_Funcs outlinefuncs =
+  {
+    FT_MoveTo,
+    FT_LineTo,
+    FT_ConicTo,
+    FT_CubicTo,
+    0, 0          /* No shift, no delta */
+  };
+
+
+  static void
+  TestFace( FT_Face  face )
+  {
+    unsigned int  gid;
+    int           load_flags = FT_LOAD_DEFAULT;
+
+
+    if ( check_outlines         &&
+         FT_IS_SCALABLE( face ) )
+      load_flags = FT_LOAD_NO_BITMAP;
+
+    if ( nohints )
+      load_flags |= FT_LOAD_NO_HINTING;
+
+    FT_Set_Char_Size( face, 0, font_size, 72, 72 );
+
+    for ( gid = 0; gid < face->num_glyphs; gid++ )
+    {
+      if ( check_outlines         &&
+           FT_IS_SCALABLE( face ) )
+      {
+        if ( !FT_Load_Glyph( face, gid, load_flags ) )
+          FT_Outline_Decompose( &face->glyph->outline, &outlinefuncs, NULL );
+      }
+      else
+        FT_Load_Glyph( face, gid, load_flags );
+
+      if ( rasterize )
+        FT_Render_Glyph( face->glyph, ft_render_mode_normal );
+    }
+
+    FT_Done_Face( face );
+  }
+
+
+  static void
+  ExecuteTest( char*  testfont )
+  {
+    FT_Library  context;
+    FT_Face     face;
+
+
+    if ( FT_Init_FreeType( &context ) )
+    {
+      fprintf( stderr, "Can't initialize FreeType.\n" );
+      exit( 1 );
+    }
+
+    if ( FT_New_Face( context, testfont, 0, &face ) )
+    {
+      /* The font is erroneous, so if this fails that's ok. */
+      exit( 0 );
+    }
+
+    if ( face->num_faces == 1 )
+      TestFace( face );
+    else
+    {
+      long  i, num;
+
+
+      num = face->num_faces;
+      FT_Done_Face( face );
+
+      for ( i = 0; i < num; i++ )
+      {
+        if ( !FT_New_Face( context, testfont, i, &face ) )
+          TestFace( face );
+      }
+    }
+
+    FT_Done_FreeType( context );
+
+    exit( 0 );
+  }
+
+
+  static int
+  extmatch( char*   filename,
+            char**  extensions )
+  {
+    int    i;
+    char*  pt;
+
+
+    if ( !extensions )
+      return true;
+
+    pt = strrchr( filename, '.' );
+    if ( !pt )
+      return false;
+    if ( pt < strrchr( filename, '/' ) )
+      return false;
+
+    for ( i = 0; extensions[i] != NULL; i++ )
+      if ( strcasecmp( pt + 1, extensions[i] ) == 0 ||
+           strcasecmp( pt,     extensions[i] ) == 0 )
+        return true;
+
+    return false;
+  }
+
+
+  static void
+  figurefiletype( struct fontlist*  item )
+  {
+    FILE*  foo;
+
+
+    item->isbinary = item->isascii = item->ishex = false;
+
+    foo = fopen( item->name, "rb" );
+    if ( foo )
+    {
+      /* Try to guess the file type from the first few characters... */
+      int  ch1 = getc( foo );
+      int  ch2 = getc( foo );
+      int  ch3 = getc( foo );
+      int  ch4 = getc( foo );
+
+
+      fclose( foo );
+
+      if ( ( ch1 == 0   && ch2 == 1   && ch3 == 0   && ch4 == 0   ) ||
+           ( ch1 == 'O' && ch2 == 'T' && ch3 == 'T' && ch4 == 'O' ) ||
+           ( ch1 == 't' && ch2 == 'r' && ch3 == 'u' && ch4 == 'e' ) ||
+           ( ch1 == 't' && ch2 == 't' && ch3 == 'c' && ch4 == 'f' ) )
+      {
+        /* ttf, otf, ttc files */
+        item->isbinary = true;
+      }
+      else if ( ch1 == 0x80 && ch2 == '\01' )
+      {
+        /* PFB header */
+        item->isbinary = true;
+      }
+      else if ( ch1 == '%' && ch2 == '!' )
+      {
+        /* Random PostScript */
+        if ( strstr( item->name, ".pfa" ) ||
+             strstr( item->name, ".PFA" ) )
+          item->ishex = true;
+        else
+          item->isascii = true;
+      }
+      else if ( ch1 == 1 && ch2 == 0 && ch3 == 4 )
+      {
+        /* Bare CFF */
+        item->isbinary = true;
+      }
+      else if ( ch1 == 'S' && ch2 == 'T' && ch3 == 'A' && ch4 == 'R' )
+      {
+        /* BDF */
+        item->ishex = true;
+      }
+      else if ( ch1 == 'P' && ch2 == 'F' && ch3 == 'R' && ch4 == '0' )
+      {
+        /* PFR */
+        item->isbinary = true;
+      }
+      else if ( ( ch1 == '\1' && ch2 == 'f' && ch3 == 'c' && ch4 == 'p' ) ||
+                ( ch1 == 'M'  && ch2 == 'Z' )                             )
+      {
+        /* Windows FON */
+        item->isbinary = true;
+      }
+      else
+      {
+        fprintf( stderr,
+                 "Can't recognize file type of `%s', assuming binary\n",
+                 item->name );
+        item->isbinary = true;
+      }
+    }
+    else
+    {
+      fprintf( stderr, "Can't open `%s' for typing the file.\n",
+               item->name );
+      item->isbinary = true;
+    }
+  }
+
+
+  static void
+  FindFonts( char**  fontdirs,
+             char**  extensions )
+  {
+    int           i;
+    unsigned int  max;
+    char          buffer[1025];
+    struct stat   statb;
+
+
+    max  = 0;
+    fcnt = 0;
+
+    for ( i = 0; fontdirs[i] != NULL; i++ )
+    {
+      DIR*            examples;
+      struct dirent*  ent;
+
+
+      examples = opendir( fontdirs[i] );
+      if ( !examples )
+      {
+        fprintf( stderr,
+                 "Can't open example font directory `%s'\n",
+                 fontdirs[i] );
+        exit( 1 );
+      }
+
+      while ( ( ent = readdir( examples ) ) != NULL )
+      {
+        snprintf( buffer, sizeof ( buffer ),
+                  "%s/%s", fontdirs[i], ent->d_name );
+        if ( stat( buffer, &statb ) == -1 || S_ISDIR( statb.st_mode ) )
+          continue;
+        if ( !extensions || extmatch( buffer, extensions ) )
+        {
+          if ( fcnt >= max )
+          {
+            max += 100;
+            fontlist = realloc( fontlist, max * sizeof ( struct fontlist ) );
+            if ( !fontlist )
+            {
+              fprintf( stderr, "Can't allocate memory\n" );
+              exit( 1 );
+            }
+          }
+
+          fontlist[fcnt].name = strdup( buffer );
+          fontlist[fcnt].len  = statb.st_size;
+
+          figurefiletype( &fontlist[fcnt] );
+          fcnt++;
+        }
+      }
+
+      closedir( examples );
+    }
+
+    if ( fcnt == 0 )
+    {
+      fprintf( stderr, "Can't find matching font files.\n" );
+      exit( 1 );
+    }
+
+    fontlist[fcnt].name = NULL;
+  }
+
+
+  static unsigned int
+  getErrorCnt( struct fontlist*  item )
+  {
+    if ( error_count == 0 && error_fraction == 0.0 )
+      return 0;
+
+    return error_count + (unsigned int)( error_fraction * item->len );
+  }
+
+
+  static int
+  getRandom( int  low,
+             int  high )
+  {
+    if ( low - high < 0x10000L )
+      return low + ( ( random() >> 8 ) % ( high + 1 - low ) );
+
+    return low + ( random() % ( high + 1 - low ) );
+  }
+
+
+  static int
+  copyfont( struct fontlist*  item,
+            char*             newfont )
+  {
+    static char   buffer[8096];
+    FILE          *good, *newf;
+    size_t        len;
+    unsigned int  i, err_cnt;
+
+
+    good = fopen( item->name, "r" );
+    if ( !good )
+    {
+      fprintf( stderr, "Can't open `%s'\n", item->name );
+      return false;
+    }
+
+    newf = fopen( newfont, "w+" );
+    if ( !newf )
+    {
+      fprintf( stderr, "Can't create temporary output file `%s'\n",
+               newfont );
+      exit( 1 );
+    }
+
+    while ( ( len = fread( buffer, 1, sizeof ( buffer ), good ) ) > 0 )
+      fwrite( buffer, 1, len, newf );
+
+    fclose( good );
+
+    err_cnt = getErrorCnt( item );
+    for ( i = 0; i < err_cnt; i++ )
+    {
+      fseek( newf, getRandom( 0, (int)( item->len - 1 ) ), SEEK_SET );
+
+      if ( item->isbinary )
+        putc( getRandom( 0, 0xFF ), newf );
+      else if ( item->isascii )
+        putc( getRandom( 0x20, 0x7E ), newf );
+      else
+      {
+        int  hex = getRandom( 0, 15 );
+
+
+        if ( hex < 10 )
+          hex += '0';
+        else
+          hex += 'A' - 10;
+
+        putc( hex, newf );
+      }
+    }
+
+    if ( ferror( newf ) )
+    {
+      fclose( newf );
+      unlink( newfont );
+      return false;
+    }
+
+    fclose( newf );
+
+    return true;
+  }
+
+
+  static int  child_pid;
+
+  static void
+  abort_test( int  sig )
+  {
+    FT_UNUSED( sig );
+
+    /* If a time-out happens, then kill the child */
+    kill( child_pid, SIGFPE );
+    write( 2, "Timeout... ", 11 );
+  }
+
+
+  static void
+  do_test( void )
+  {
+    int         i        = getRandom( 0, (int)( fcnt - 1 ) );
+    static int  test_num = 0;
+    char        buffer[1024];
+
+
+    sprintf( buffer, "%s/test%d", results_dir, test_num++ );
+
+    if ( copyfont ( &fontlist[i], buffer ) )
+    {
+      signal( SIGALRM, abort_test );
+      /* Anything that takes more than 20 seconds */
+      /* to parse and/or rasterize is an error.   */
+      alarm( 20 );
+      if ( ( child_pid = fork() ) == 0 )
+        ExecuteTest( buffer );
+      else if ( child_pid != -1 )
+      {
+        int  status;
+
+
+        waitpid( child_pid, &status, 0 );
+        alarm( 0 );
+        if ( WIFSIGNALED ( status ) )
+          printf( "Error found in file `%s'\n", buffer );
+        else
+          unlink( buffer );
+      }
+      else
+      {
+        fprintf( stderr, "Can't fork test case.\n" );
+        exit( 1 );
+      }
+      alarm( 0 );
+    }
+  }
+
+
+  static void
+  usage( FILE*  out,
+         char*  name )
+  {
+    char**  d = default_dir_list;
+    char**  e = default_ext_list;
+
+
+    fprintf( out, "%s [options] -- Generate random erroneous fonts\n"
+                  "  and attempt to parse them with FreeType.\n\n", name );
+
+    fprintf( out, "  --all                    All non-directory files are assumed to be fonts.\n" );
+    fprintf( out, "  --check-outlines         Make sure we can parse the outlines of each glyph.\n" );
+    fprintf( out, "  --dir <path>             Append <path> to list of font search directories\n"
+                  "                           (no recursive search).\n" );
+    fprintf( out, "  --error-count <cnt>      Introduce <cnt> single byte errors into each font\n"
+                  "                           (default: 1)\n" );
+    fprintf( out, "  --error-fraction <frac>  Introduce <frac>*filesize single byte errors\n"
+                  "                           into each font (default: 0.0).\n" );
+    fprintf( out, "  --ext <ext>              Add <ext> to list of extensions indicating fonts.\n" );
+    fprintf( out, "  --help                   Print this.\n" );
+    fprintf( out, "  --nohints                Turn off hinting.\n" );
+    fprintf( out, "  --rasterize              Attempt to rasterize each glyph.\n" );
+    fprintf( out, "  --results <path>         Place the created test fonts into <path>\n"
+                  "                           (default: `results')\n" );
+    fprintf( out, "  --size <float>           Use the given font size for the tests.\n" );
+    fprintf( out, "  --test <file>            Run a single test on an already existing file.\n" );
+    fprintf( out, "\n" );
+
+    fprintf( out, "Default font extensions:\n" );
+    fprintf( out, " " );
+    while ( *e )
+      fprintf( out, " .%s", *e++ );
+    fprintf( out, "\n" );
+
+    fprintf( out, "Default font directories:\n" );
+    fprintf( out, " " );
+    while ( *d )
+      fprintf( out, " %s", *d++ );
+    fprintf( out, "\n" );
+  }
+
+
+  int
+  main( int     argc,
+        char**  argv )
+  {
+    char    **dirs, **exts;
+    int     dcnt = 0, ecnt = 0, rset = false, allexts = false;
+    int     i;
+    time_t  now;
+    char*   testfile = NULL;
+
+
+    dirs = calloc( (size_t)( argc + 1 ), sizeof ( char ** ) );
+    exts = calloc( (size_t)( argc + 1 ), sizeof ( char ** ) );
+
+    for ( i = 1; i < argc; i++ )
+    {
+      char*  pt = argv[i];
+      char*  end;
+
+
+      if ( pt[0] == '-' && pt[1] == '-' )
+        pt++;
+
+      if ( strcmp( pt, "-all" ) == 0 )
+        allexts = true;
+      else if ( strcmp( pt, "-check-outlines" ) == 0 )
+        check_outlines = true;
+      else if ( strcmp( pt, "-dir" ) == 0 )
+        dirs[dcnt++] = argv[++i];
+      else if ( strcmp( pt, "-error-count" ) == 0 )
+      {
+        if ( !rset )
+          error_fraction = 0.0;
+        rset = true;
+        error_count = (unsigned int)strtoul( argv[++i], &end, 10 );
+        if ( *end != '\0' )
+        {
+          fprintf( stderr, "Bad value for error-count: %s\n", argv[i] );
+          exit( 1 );
+        }
+      }
+      else if ( strcmp( pt, "-error-fraction" ) == 0 )
+      {
+        if ( !rset )
+          error_count = 0;
+        rset = true;
+        error_fraction = strtod( argv[++i], &end );
+        if ( *end != '\0' )
+        {
+          fprintf( stderr, "Bad value for error-fraction: %s\n", argv[i] );
+          exit( 1 );
+        }
+        if ( error_fraction < 0.0 || error_fraction > 1.0 )
+        {
+          fprintf( stderr, "error-fraction must be in the range [0;1]\n" );
+          exit( 1 );
+        }
+      }
+      else if ( strcmp( pt, "-ext" ) == 0 )
+        exts[ecnt++] = argv[++i];
+      else if ( strcmp( pt, "-help" ) == 0 )
+      {
+        usage( stdout, argv[0] );
+        exit( 0 );
+      }
+      else if ( strcmp( pt, "-nohints" ) == 0 )
+        nohints = true;
+      else if ( strcmp( pt, "-rasterize" ) == 0 )
+        rasterize = true;
+      else if ( strcmp( pt, "-results" ) == 0 )
+        results_dir = argv[++i];
+      else if ( strcmp( pt, "-size" ) == 0 )
+      {
+        font_size = (FT_F26Dot6)( strtod( argv[++i], &end ) * 64 );
+        if ( *end != '\0' || font_size < 64 )
+        {
+          fprintf( stderr, "Bad value for size: %s\n", argv[i] );
+          exit( 1 );
+        }
+      }
+      else if ( strcmp( pt, "-test" ) == 0 )
+        testfile = argv[++i];
+      else
+      {
+        usage( stderr, argv[0] );
+        exit( 1 );
+      }
+    }
+
+    if ( allexts )
+    {
+      free( exts );
+      exts = NULL;
+    }
+    else if ( ecnt == 0 )
+    {
+      free( exts );
+      exts = default_ext_list;
+    }
+
+    if ( dcnt == 0 )
+    {
+      free( dirs );
+      dirs = default_dir_list;
+    }
+
+    if ( testfile )
+      ExecuteTest( testfile );         /* This should never return */
+
+    time( &now );
+    srandom( (unsigned int)now );
+
+    FindFonts( dirs, exts );
+    mkdir( results_dir, 0755 );
+
+    forever
+      do_test();
+
+    return 0;
+  }
+
+
+/* EOF */
diff -Nur freetype-2.8/src/truetype/ttinterp.c freetype-2.8.compiles-with-mactype/src/truetype/ttinterp.c
--- freetype-2.8/src/truetype/ttinterp.c	2017-05-03 16:42:13.000000000 -0500
+++ freetype-2.8.compiles-with-mactype/src/truetype/ttinterp.c	2017-10-09 19:43:59.002834500 -0500
@@ -5753,6 +5753,7 @@
 
       if ( exc->ignore_x_mode                                 &&
            exc->GS.freeVector.x != 0                          &&
+           exc->GS.freeVector.y == 0                          &&
            !( exc->sph_tweak_flags & SPH_TWEAK_NORMAL_ROUND ) )
         control_value_cutin = 0;
     }
